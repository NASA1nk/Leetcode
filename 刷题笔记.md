# 算法性质

- 有穷性

- 确定性

- 可行性

- 输入

- 输出


# 算法分析

- 比较算法性能
  - 分析**最坏情况**下算法运行时间
- 输入规模n
  - 时间复杂度 `T(n)`
- **渐进分析**：
  - 忽略T(n)的系数和低阶项，**只关注高阶项**
    - 渐进紧确界`O(n)`
    - 渐进上界`θ(n)`
    - 渐进下界`Ω(n)`

> 调和级数：logn

通常最坏情况确定上界，用渐进上界`O(n)`表示时间复杂度





# 数据结构

## 底层存储方式

- 数组：顺序存储
  - 连续存储，随机访问
  - 必须一次性分配足
  - 扩容，插入，删除：时间复杂度o(n)
- 链表：链式存储
  - 不能随机访问
  - 存储指针域，消耗更多存储空间
  - 插入，删除：时间复杂度o(1)



## 基本操作

遍历+访问：增删改查

- 线性：`for`,`while`
- 非线性：递归

```java
// 链表遍历框架：迭代
for(ListNode p = head; p != null; p = p.next){
    
}
```



# Sort

## 排序算法的稳定性

- 待排序的记录序列中可能存在两个或两个以上的关键字相等的记录**排序结果可能会存在不唯一的情况**
- 排序之后如果相等元素之间**原有的先后顺序不变**，则称所用的排序方法是**稳定的**，反之则称之为**不稳定的**

稳定排序可以让第一个关键字排序的结果服务于第二个关键字排序中数值相等的那些数

## 排序的分类

### 比较类和非比较类

- 根据元素是否依靠与其他元素的比较来决定元素间的相对次序，以此来区分比较类排序算法和非比较类排序算法

### 内排序和外排序

- 内排序是在排序的整个过程中，待排序的所有记录全部被放置在内存中
- 外排序是由于排序的记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行

常见的内排序算法有

- 插入排序
- 希尔排序
- 选择排序
- 冒泡排序
- 归并排序
- 快速排序
- 堆排序
- 基数排序

> 对内排序来说，主要受三个方面影响，时间性能，辅助空间，算法的复杂性

## 冒泡排序

比较类排序

**两两比较相邻记录的元素，如果是反序则交换**

- 一次冒泡会让至少一个元素移动到它应该在的位置，n个元素重复n次后能完成排序

**时间复杂度**

- 最好情况：待排序的数组有序，只需要一次遍历，n-1次比较，时间复杂度为`o(n)`
- 最坏情况：待排序数组逆序，则需要比较(n-1)+(n-2)+...+2+1 = n*(n-1)/2，时间复杂度为`o(n^2)`
- 平均情况：需要n*(n-1)/4次交换操作，比较操作大于等于交换操作，时间复杂度就是`o(n^2)`

> 相等时不交换位置，所以是稳定的

```java
public int[] Bubble Sort(int[] nums) {
    // 记录数组是否有序，有序不用再遍历
    boolean flag = true;
    for (int i = 0; i < nums.length && flag; i++) {
        // 如果没发生交换就有序，下次跳出循环
        flag = false;
        for (int j = 0; j < nums.length - i - 1; j++) {
            if (nums[j] > nums[j+1]) {
                swap(nums[j],nums[j+1]);
                // 发生交换则无序，下次继续判断
                flag = true;
            }
        }
    }
    return nums;
}
```



## 选择排序

每次从未排序的数组中选出最小的元素，将最小的元素和未排序部分的开始元素交换

- 贪心：每一次决策只看当前，当前最优则全局最优
- 减治：外层循环每一次都能排定一个元素，问题的规模逐渐减少，直到全部解决


**优点**

- 交换次数最少，在交换成本较高的排序任务中，就可以使用选择排序

> 减治思想的典型算法就是二分查找

```java
public int[] sortArray(int[] nums) {
    // [0, i)有序，区间里元素就是最终顺序
    for (int i=0; i<nums.length-1; i++) {
        // 选择区间[i, nums.length-1]中最小的元素交换
        int minn = i;
        for (int j=i+1; j<len; j++) {
            if (nums[j] < nums[minn]) {
                minn = j;
            }
        }
        swap(nums[i],nums[minn]);
    }
    return nums;
}
```

## 插入排序

将排序好的数组从后往前与未排序的元素一一对比，将元素插入到对应位置

**优点**

- 在数组几乎有序的前提下，插入排序的时间复杂度可以达到`O(n)`
- 插入排序在短数组上的表现也很好
  - 因为短数组的特点是每个元素离它最终排定的位置都不会太远，所以在小区间内执行排序任务的时候，可以使用插入排序

> 在Java排序源码中，小区间也改用插入排序
>
> - `Arrays.sort()`当元素个数少于47时，使用的排序算法就是插入排序
>
> ```java
> // 列表大小等于或小于该大小，将优先于mergeSort使用插入排序
> // 小区间的长度是个超参数，需要测试决定
> private static final int INSERTION_SORT_THRESHOLD = 47;
> 
> if (right - left <= INSERTION_SORT_THRESHOLD) {
>     insertionSort(nums, left, right);
>     return;
> }
> ```

```java
public int[] insertionSort(int[] nums) {
    // 将nums[i]插入到区间[0, i)使之成为有序数组
    for (int i=1; i<nums.length; i++) {
        // 先暂存元素，不用逐步交换
        int temp = nums[i];
        int j = i;
        while (j > 0 && nums[j-1] > temp) {
            nums[j] = nums[j-1];
            j--;
        }
        nums[j] = temp;
    }
    return nums;
}
```

## 希尔排序

希尔排序是**插入排序**的一种，又称**缩小增量排序**（Diminishing Increment Sort）

- 希尔排序是插入排序的高级变形，是有跨度的插入排序，这个跨度会逐渐变小直到变为1，**变为1时基本有序**，这时用到的就是插入排序

**基本有序**

- 就是小的关键字基本在前面，大的关键字基本在后面，不大不小的基本在中间

## 快速排序

交换排序

> 20世纪十大算法之一

**缺点**

- 当数组是有序的，且每一轮排序都已最后一个数字做比较的数字，时间复杂度是`o(n^2)`
- 所以`pivot`最好是随机选取，否则遇到极端测试用例复杂度太高

> 如果写i,x不能取q[l]，如果写j,x不能取q[r]，会死循环

```java
public int[] quickSort(int[] nums, int low, int high, int k) {
    // 每快排划分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数
    int pivot = partition(nums, low, high);
    if (pivot == k) {
        return Arrays.copyOf(nums, pivot + 1);
    }
    // 否则根据下标pivot与k的大小关系来决定继续切分左段还是右段。
    return pivot > k? quickSearch(nums, lo, pivot - 1, k): quickSearch(nums, pivot + 1, hi, k);
}

// 快排划分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。
public int partition(int[] nums, int low, int high) {
    int v = nums[low];
    int i = low,
    pivot = hi + 1;
    while (true) {
        while (++i <= hi && nums[i] < v);
        while (--j >= lo && nums[j] > v);
        if (i >= j) {
            break;
        }
        // 交换
        int t = nums[j];
        nums[j] = nums[i];
        nums[i] = t;
    }
    nums[lo] = nums[j];
    nums[j] = v;
    return pivot;
}
```

```java
public int partition(int[] nums, int left, int right) {
        int randomIndex = RANDOM.nextInt(right - left + 1) + left;
        swap(nums, left, randomIndex);

        int pivot = nums[left];
        // 此时只是双指针，并没有lt、gt的含义了
        int l = left;
        int r = right;

        while (l < r) {

             // (除初次外) 上轮循环结束后，有： nums[l]  < pivot , nums[r] > pivot，原因下述有写


            // 两个循环条件：
            // 1. 由 nums[r] < pivot 跳出
            // 2. 由 l >= r 跳出 ，此时 r = l , 而 nums[l] < pivot
            // 因此无论条件导致跳出，都有 nums[r] < pivot

            // 需要先进行r的操作，也是为了利用上一轮 nums[l] < pivot 的条件。
            // 而如果先进行l的操作，如果因为 l >= r 跳出，那此时 nums[l] = nums[r] > pivot，就不符合要求了
            while (l < r && nums[r] >= pivot) r--;

            // 同样的有两个跳出条件：
            // 1. nums[l] > pivot
            // 2. l >= r , 此时 l = r , 而据上分析，nums[r] < pivot，此时 nums[l] = nums[r] < pivot
            while (l < r && nums[l] <= pivot) l++;

            // 总结：两个循环结束，有两种情况：
            // 1. l < r , nums[l] > pivot , nums[r] < pivot 。
            // 2. l = r , nums[l] = nums[r] < pivot

            // 其实有无都可，但更清晰
            if(l >= r) break;

            swap(nums, l, r);

            // 交换后，对上述情况
            // 1.  nums[l] < pivot , nums[r] > pivot
            // 2.  nums[l] = nums[r]  < pivot

            // 即一定有 : nums[l] < pivot ，而交换前的判断 if(l < r) 有无都不影响该结论
            // 虽然nums[r] 跟 pivot 大小比较，在两种情况下，是不一样。
            // 但对于第二种情况，后续循环就会跳出，因此对于下一轮循环，是一定有: nums[r] > pivot，nums[l] < pivot的

            // 完成交换后，也不主动l++，r--，也是为了保证 nums[l] < pivot
        }

        // 外循环结束后， l = r ,哪个都对
        swap(nums, l, left);

        return l;
    }

```



## 归并排序

2路归并排序

1. 递归
2. 合并

> 时间复杂度：`o(nlogn)`

**问题特点**

- 局部有序性

**步骤**

1. 处理待排序数组（不具备局部有序性的特点）：**分解至数组长度为1时天然有序**

2. 递归解决子问题：得到2个有序数组

3. 合并有序子数组

   > 快速合并：比较2个有序数组的当前最小元素，将较小者逐一合并 

**递归实现**

```java
int[] tmp = new int[n];
public void mergeSort(int[] nums,int l,int r){
    if(l >= r){
        return;
    }
    // Java里有更优的写法，在l和r都是大整数时，即使溢出结论依然正确
    // int mid = (l + r) >>> 1;
    int mid = l + (r - l) / 2;
    // 划分区间为[l,mid]和[mid+1,r]
    mergeSort(nums, l, mid);
    mergeSort(nums, mid+1, r);
    int k = 0;
    int i = l;
    int j = mid + 1;			
    // Merge
    while(i <= mid && j <= r){				
        if(nums[i] <= nums[j]){
            tmp[k++] = nums[i++];
        }
        else{
            tmp[k++] = nums[j++];
        } 
    }
    // 未合并的部分直接放在最后
    while(i <= mid){
        tmp[k++] = nums[i++];
    }
    while(j <= r){
        tmp[k++] = nums[j++];
    }
}
```

**迭代实现**

# 水题

## [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)

int范围：-2147483648~2147483647（10位数）

在循环中判断溢出：if ((ans * 10) / 10 != ans)

ans * 10未溢出时 ans * 10个位为0, 故ans * 10 + x%10没有进位。但并不是没有进位就不溢出，而是末位是正数不能大于7，是负数不能小于-8 。但**原数在int范围内，当它是10位数时才可能溢出，此时第一位一定是1或2** 。那么反转最后一位也就是1或2，那么ans * 10加上它也不会溢出。

> (ans * 10)溢出的时候Java可以暂存，C不可以

## [9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

考虑只反转int数字的一半：如何判断位数到一半了（奇，偶？）

- 奇位数的中间位数字不影响回文

- 当**原始数字小于或等于反转后的数字**时，表示已经处理了一半位数的数字


```c
while (x > revertedNumber) {
    revertedNumber = revertedNumber * 10 + x % 10;
    x /= 10;
}
```



# Array数组

## [169. 主要元素](https://leetcode-cn.com/problems/find-majority-element-lcci/)

数组中一个数出现的次数超过数组长度的一半

- 那么在排序后，出现在数组中间的数字一定就是那个数
  - 统计学上的中位数：有一半的数比它大，有一半的数比它小
- 它出现的次数比其他所有数出现的次数都多
  - 用其他数和它消除，最后还会剩下它

# BinarySearch二分搜索

- **else if**
  - 将所有的条件写成`else if`，不使用`else`
- **mid**
  - 防止left和right太大直接相加导致溢出

```java
int l = 0;
int r = nums.length-1;
while(l <= r){
    int mid = l + (r - l) / 2;
    if(nums[mid] > target){
        r = mid - 1;
    }
    else if(nums[mid] < target){
        l = mid + 1;
    }
    else if(nums[mid] == target){
        return mid;
    }
}
return -1;
```

## 搜索区间

**搜索闭区间[left,right]**

- 当没有搜索到目标值时，`left = right+1 (left > right)`循环时终止
- 此时**区间为空**，返回-1即可

```java
// 1.
int left = 0;
int right = nums.length-1;
while(left <= rigth){
    
}
```

**搜索开区间[left,right)**

- 当没有搜索到目标值时，`left = right`时循环终止
- 此时**区间非空**，是`[right,right]`，所以还需要单独判断`nums[right]`

> right = nums.length则不用单独判断

```java
// 2.
int left = 0;
int right = nums.length-1;
while(left < rigth){
    
}
```



**left/right**

当`nums[mid]`不满足条件，继续搜索计算区间时

**搜索闭区间[left,right]**

`mid`已经包含在搜索区间中了，下一步搜索

- `[left,mid-1]`
- `[mid+1,right]`

所以两个区间都要剔除`mid`

```java
left = mid+1;
right = mid-1;
```

**搜索开区间[left,right)**

右边是开区间，包括`left`，不包括`right`，所以下一步搜索

- `[left,mid)`
  - 需要剔除`mid`
- `[mid,right)`
  - 不需要剔除`mid`

```java
left = mid+1;
right = mid;
```



## 左侧边界

其实就是在**找到值时继续向左搜索值**

- **左侧边界的意义**
  - 排序数组中，小于`nums[l]`的数有`l`个
- **return left**
  - 闭区间时，最后搜索到值后是在`left = right + 1`结束，所以`left`的取值范围是`[0,nums.length]`
  - 所以需要单独判断越界：`left = nums.length`
  - 并且因为寻找左侧边界时只是一直在缩小区间上界范围，所以还需要判断是否找到了值：`nums[left] = target`

```java
int l = 0;
int r = nums.length-1;
while(l <= r){
    int mid = l + (r - l) / 2;
    if(nums[mid] > target){
        r = mid - 1;
    }
    else if(nums[mid] < target){
        l = mid + 1;
    }
    else if(nums[mid] == target){
        r = mid - 1;
    }
}
if(l >= nums.length || nums[l] != target){
    return -1;
}
return l;
```



## 右侧边界

```java
int l = 0;
int r = nums.length-1;
while(l <= r){
    int mid = l + (r - l) / 2;
    if(nums[mid] > target){
        r = mid - 1;
    }
    else if(nums[mid] < target){
        l = mid + 1;
    }
    else if(nums[mid] == target){
        l = mid + 1;
    }
}
if(r < 0 || nums[r] != target){
    return -1;
}
return r;
```



# 快速幂

时间复杂度：`o(logn)`

## 整数快速幂

### 二分思想

$x^n = (x^{n/2})^2$

- 当n为偶数：$x^n = (x^{n/2})^2$
- 当n为奇数：$x^n = x*(x^{n/2})^2$

```java
// 递归快速幂
int fastpower(int a, int n)
{
    if (n == 0)
        return 1;
    if (n % 2 == 1)
        return fastpower(a, n-1) * a;
    // 记录temp,否则会计算两次n/2
    int temp = fastpower(a, n/2);
    return temp * temp;
}
```

### 二进制思想


对于一个十进制数n，设n的二进制的表示为：$b_mb_{m-1}...b_2b_1$（$b_i$为二进制位上的值，$i∈[1,m]$）

即：$n = 2^{m-1}*b_m + 2^{m-2}*b_{m-1}+...+2^1*b_2+2^0*b_1$

所以有：$x^n = x^{2^{m-1}*b_m + 2^{m-2}*b_{m-1}+...+2^1*b_2+2^0*b_1}$

即：$x^n = x^{2^{m-1}*b_m}*x^{2^{m-2}*b_{m-1}}*...*x^{2^1*b_2}*x^{2^0*b_1}$

所以求$x^n$

1. 因为$b_i$的取值只有0或者1
   1. 当$b_i = 0$时，$x^{2^{i-1}*b_i} = x^0 = 1$
   2. 当$b_i = 1$时，$x^{2^{i-1}*b_i} = x^{2^{i-1}}$，即求出$x^1，x^2，x^4，x^8 ... x^{2^{m-1}}$
2. 获取n对应的二进制的各位值$b_i$
   1. n&1：判断二进制最右一位（最低位）的值
   2. n>>1：右移1位，继续判断

> $x^{-n} = {1/x}^n$

```java
public double fastPower(double x, int n) {
    if(x == 0){
        return 0;
    }
    // int32变量n∈[-2147483648,2147483647]
    // 当n=-2147483648时，n = -n会越界出错，所以先将n存入long变量m，再用m操作
    long m = n;
    if(m < 0) {
        x = 1 / x;
        m = -m;
    }
    double ans = 1.0;
    while(m > 0) {
        if((m & 1) == 1){
            ans = ans*x;
        }
        // 求x^1，x^2，x^4，x^8...
        x = x*x;
        m = m >> 1;
    }
    return ans;
}
```

## 快速幂取模

求 $a^b \mod c$

- $a^b \mod c = (a \mod c)^{(b \mod c)}$
- $a*b \mod c = (a \mod c)*(b \mod c) \mod c$
  - 计算 $a*b \mod c$ 使用`long long`也有可能爆精度，此时需要转乘法为加法，在模拟的同时不断求模

```java
public int fastPower(int a, int n)
{
    if (n == 0)
        return 1;
    if (n % 2 == 1)
        return fastPower(a, n-1) % mod * (a % mod);
    int temp = fastPower(a, n/2) % mod;
    return temp * temp % mod;
}

public double fastPower(double x, int n) {
    if(x == 0){
        return 0;
    }
    long m = n;
    if(m < 0) {
        x = 1 / x;
        m = -m;
    }
    double ans = 1.0;
    while(m > 0) {
        if((m & 1) == 1){
            ans = (ans*x) % mod;
        }
        // 求x^1，x^2，x^4，x^8...
        x = (x*x) % mod;
        m = m >> 1;
    }
    return ans;
}
```



## 矩阵快速幂

在计算$x^n$时，只要x的数据类型支持**乘法**且**满足结合律**，快速幂的算法都是有效的，矩阵和高精度整数都可以

- 较复杂类型的快速幂的时间复杂度不再是简单的`o(logn)`，它与底数的乘法的时间复杂度有关
- 需要重载相应的乘法运算符

```java
// 泛型的非递归快速幂
template <typeName T>
T  fastPower(T x, ll n)
{
    // 赋值为乘法单位元，可能要根据构造函数修改
    T ans = 1; 
    while (n)
    {
        if (n & 1)
            // 这里不用自乘，否则重载完*还要重载*=
            ans = ans * x; 
        n = n >> 1;
        x = x * x;
    }
    return ans;
}
```

**矩阵快速幂**的经典应用

- 求斐波那契数列

斐波那契数列
$$
F_n=
\left\{
\begin{aligned}
1, \quad n=0\\
1, \quad n=1\\
F_{n-1}+F_{n-2} \quad x\ge1\\
\end{aligned}
\right.
$$

矩阵A
$$
A = \left[\begin{matrix}0&1\\1&1\end{matrix}\right]
$$

矩阵乘法可以得到
$$
A \left[\begin{matrix}F_n\\F_{n+1}\end{matrix}\right] = \left[\begin{matrix}F_{n+1}\\F_n+F_{n+1}\end{matrix}\right]
=
\left[\begin{matrix}F_{n+1}\\F_{n+2}\end{matrix}\right]
$$
即
$$
\left[\begin{matrix}F_{n}\\F_{n+1}\end{matrix}\right]
= A \left[\begin{matrix}F_{n-1}\\F_n\end{matrix}\right]
= A^2 \left[\begin{matrix}F_{n-2}\\F_{n-1}\end{matrix}\right]
= A^{n-1} \left[\begin{matrix}F_1\\F_2\end{matrix}\right]
= A^n \left[\begin{matrix}F_0\\F_1\end{matrix}\right]
= A^n \left[\begin{matrix}1\\1\end{matrix}\right]
= A^n+A^n
= 2*A^n
$$

> 处理矩阵的乘法



# LinkedList链表

## [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

删除

- 只要这个点的值变成下一个点的值，就表示这个点不在了
- 只适用于非末尾节点

```c
node->val = node->next->val;
node->next = node->next->next;
```

## [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

**哨兵节点**

- 当要删除的一个或多个节点位于链表的头部，需要定位新的链表头指针`pre`

- 删除操作需要通过`next`指针域判断，定义`pre`指针方便操作

**双指针**

- 正常`cur`指针从`head`开始判断整个链表
  - `cur->val != val`时2个指针同时向后移动一位

  - `cur->val == val`时删除这个节点，并且下次移动的时候`pre`指针需要跳过这个点



## [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)


- **栈**

  - 倒序天然适合栈操作
- **双指针**

  - 前指针`former`先走k步，然后两个指针一起走直到`former`为`null`
  - 因为指针相距k步，后指针`latter`刚好在倒数节点处

> **模n同余**
>
> - 给定一个正整数m，如果两个整数a和b满足 a-b 能够被m整除，那么就称整数a与b对模m同余，记作a≡b(mod m)。对模m同余是整数的一个等价关系

## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

- **递归**

  每次处理递归返回的尾节点是当前head的下一个节点

  ```c
  struct ListNode* reverseList(struct ListNode* head);
  
  last = reverseList(head->next);
  head->next->next = head;
  head->next = NULL;
  ```

- **迭代**

  每次将当前节点从链上摘下来放在前面一个节点的前面
  
  ```C
  pre->next = head;
  h = head;
  cur = head->next;
  
  while (cur) {
      h->next = cur->next;
      cur->next = pre->next;
      pre->next = cur;
      cur = h->next;
  }
  ```

  

## [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

**快慢指针**

- 慢指针一次走1步，快指针一次走2步
- 当快指针走完的时候慢指针就来到了链表的中间位置


```java
// 注意边界判断
fast = slow = head;
while (fast != null && fast.next != null) {
    fast = fast.next.next;
    slow = slow.next;
}
return slow 	
```

## [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

**快慢指针**

- 如果链表存在环，快指针最后会追上慢指针
  - 在环中相遇
- 慢指针如果走了`k`，则快指针走了`2k`。差距`k`就是环的长度`l`的整数倍
  - 因为可能慢指针还没进入环的时候，快指针已经在环中循环n圈了，即`k = n * l`（l为环的长度）

```java
fast = slow = head;
while (fast != null && fast.next != null) {
    fast = fast.next.next;
    slow = slow.next;
	if(fast == slow){
        return true;
    }
}
return false;
```



## [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

**快慢指针**

1. 当快指针追到慢指针时，加速慢指针走了k，则快指针走了2k
2. 假设环的入口点和快慢指针的相遇点相距`m`，因为慢指针走了k，所以链表头节点`head`和入口点相距`k-m`
   1. 是从入口到相遇点，不是从相遇点到入口
3. 因为`k`是环长`l`的整数倍，所以慢指针再走`k-m`就相当于从入口处走了`k`，即绕了`n`圈回到了入口处
   1. 而`head`走`k-m`也会到达入口，所以相遇点就是环的入口

```java
ListNode fast = head;
ListNode slow = head;
while(fast != null && fast.next != null){
    fast = fast.next.next;
    slow = slow.next;
    if(fast == slow){
        fast = head;
        while(fast != slow){
            fast = fast.next;
            slow = slow.next;
        }
        return fast;
    }
}        
return null;
```



## [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

**双指针**

# Stack/Queue栈和队列

## [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

- 中缀表达式：正常使用的表达式，运算符在两个操作数的中间（a+b）由优先级判断顺序

- 后缀表达式（逆波兰式）：**运算符跟在两个操作数后**（abcde/-f+）

  运算规则：每个运算符和在它之前出现且紧靠它的两个操作数构成一个最小表达式

  **在堆栈中括号的优先级最低**

- 前缀表达式（波兰式）：**运算符在两个操作数前**（+ab-c/def）

  运算规则：连续出现的两个操作数和它们之前且紧靠它们的运算符构成一个最小表达式



 



# BinaryTree二叉树

**递归**

用自身定义自身

- 递归边界
- 递归式：和大问题性质相似的小问题

## 二叉树

- 严格区分左右子树
- 叶子节点数为n，度为2的节点数为m，则**n=m+1**

> 和度为2的树的最主要区别

### 二叉链表

```c++
struct TreeNode{
    int data;
    TreeNode* lchild;
    TreeNode* rchild;
};

TreeNode* root = NULL;
```

### 静态二叉链表

- 用长度为二叉树节点个数的数组实现
- 所有动态生成的节点都用数组中的节点
- 使用数组下标访问二叉树的节点（代替指针）

```c++
struct TreeNode{
    int data;
    int lchild;
    int rchild;
}Node[maxn];
```

### 特殊的二叉树

- 斜树
  - 左斜树
  - 右斜树
- 满二叉树（完美）
  - 所有分支节点都存在左右子树
  - 所有叶子节点都在同一层
- 完全二叉树
  - 所有节点和同样深度的满二叉树的节点一一对应
  - 叶子节点只能出现在最下面**两层**
    - 最下层的叶子节点一定在左边连续位置
    - 倒数第二层的叶子节点一定在右边连续位置
  - 不存在只有右子树的节点（度为1一定是只有左子树）
  - 同样节点的数的二叉树，**深度最小**（n个节点深度为**向下取整(logn)+1**）

> 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树

**完全二叉树的存储**

可以使用长度为**2<sup>n</sup>**的数组存储所有节点

- nums[1]存放根节点
- n为完全二叉树的最大高度，即数组长度为完全二叉树的**节点总数+1**
- 数组中存放完全二叉树的节点顺序刚好是**层序遍历的顺序**

假设完全二叉树的任一节点编号为n

- 节点左孩子编号为**2*n**
- 节点右孩子编号为**2*n+1**

## 二叉树的插入

插入位置就是查找失败的位置

- 建树就是不断向二叉树插入节点

## 二叉树的遍历

### 深度优先搜索DFS

左子树一定先于右子树遍历

- 前序遍历preorder
- 中序遍历inorder
- 后序遍历hostorder

### 广度优先搜索BFS

- 层序遍历

  - 非递归：队列实现

```java
// LinkedList实现Queue接口
Queue<TreeNode> q = new LinkedList<>();
q.add(root);
// Queue<TreeNode> q = new LinkedList<>(){{ add(root); }};
while(!q.isEmpty()){
    TreeNode node = q.poll();
    // 层序遍历
    t.add(node.val);
    if(node.left != null){
        q.offer(node.left);
    }
    if(node.right != null){
        q.offer(node.right);
    }
}
```

分层遍历

```java
List<List<Integer>> ans = new LinkedList<>();
Queue<TreeNode> q = new LinkedList<>();
q.offer(root);
while(!q.isEmpty()){
    List<Integer> t = new LinkedList<>();
    // 使用i初始化，保证不会因为q.size()改变而出错
    for(int i=q.size(); i>0; i--){
        TreeNode node = q.poll();
        t.add(node.val);
        if(node.left != null){
            q.offer(node.left);
        }
        if(node.right != null){
            q.offer(node.right);
        }
    }
    ans.add(t);
}
```



## 二叉树的还原

**根据遍历结果还原二叉树**

- 前序，后序，层遍历可以获得**根节点**
- 中序遍历可以根据前后序遍历获得的根节点来区分**左右子树**

> 必须知道中序遍历才能还原二叉树
>
> 必须要保证所有节点值不相同

**还原过程**

前序遍历：[p<sub>1</sub>，p<sub>2</sub>...p<sub>k</sub>，p<sub>k+1</sub>...p<sub>n</sub>]

中序遍历：[i<sub>1</sub>，i<sub>2</sub>...i<sub>k-1</sub>，i<sub>k</sub>，i<sub>k+1</sub>...i<sub>n</sub>]

1. 根据前序遍历得出p<sub>1</sub>是根节点root
2. 在中序遍历中找到**i<sub>k</sub>=p<sub>1</sub>**，根据i<sub>k</sub>划分左右子树
3. 根据中序遍历得出左子树节点个数**n=k-1**
4. 根据n得出在前序遍历中左子树的区间为[p<sub>2</sub>,p<sub>k</sub>]，右子树区间为[p<sub>k+1</sub>,p<sub>n</sub>]
5. 根据n得出在中序遍历中左子树的区间为[i<sub>1</sub>,i<sub>k-1</sub>]，右子树区间为[i<sub>k+1</sub>,i<sub>n</sub>]
6. 根据左，右子树的前，中序遍历递归还原二叉树

> 子树的前序遍历区间是[p<sub>l</sub>,p<sub>r</sub>]，中序遍历区间是[i<sub>l</sub>,i<sub>r</sub>]，且i<sub>k</sub>=p<sub>l</sub>，则左子树节点个数n=k-i<sub>l</sub>
>
> 左子树的前序遍历区间为[p<sub>l+1</sub>,p<sub>l+n</sub>]，左子树的中序遍历区间为[i<sub>l</sub>,i<sub>k-1</sub>]
>
> 右子树的前序遍历区间为[p<sub>l+n+1</sub>,p<sub>r</sub>]，左子树的中序遍历区间为[i<sub>k+1</sub>,i<sub>r</sub>]

**递归终止条件**

- 当前序区间长度<=0时结束（不存在二叉树）


```java
public TreeNode create(int[] pre,int[] in,int pl,int pr,int il,int lr){
    // 递归终止
    if(pl > pr){
        return null;
    }
    // 创建根节点
    TreeNode root = new TreeNode(pre[pl]);
    int i;
    for(i=il; i<=ir; i++){
        if(in[i] == pre[pl]){
            break;
        }
    }
    int n = i-il;
    root.left = create(pre,in,pl+1,pl+n,il,i-1);
    root.right = create(pre,in,pl+n+1,pr,i+1,ir);
    return root;
}
```



## [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

**树的高度和深度**

- 深度定义是从上往下的
- 高度定义是从下往上的

**树的遍历**

- 前序遍历：根左右，从上往下，符合深度定义的
- 后序遍历：左右根，从下往上，符合高度定义的

## [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

最小深度是从根节点到最近叶子节点的最短路径上的节点数量

当只有一棵子树为空时，哪条路径不是叶子节点路径

解决方法：不参与比较



## 二叉搜索树



# BitOperation位运算

- `&`
  - 与：两个位都为1时，结果才为1
  - 如果想将一个单元清零，只要与一个各位都为零的数值相与
- `|`
  - 或：两个位都为0时，结果才为0
- `^`
  - 异或：两个位相同为0，相异为1
- `~`
  - 取反：0变1，1变0

## [1470. 重新排列数组](https://leetcode-cn.com/problems/shuffle-the-array/)

**思路一**

数据是二进制表示，**用数存数**

题目限制数据范围最大只能是1000，所以每一个元素最多只占据了10bit（2^10 - 1 = 1023 > 1000）而`int`类型占32bit，所以可以使用剩下的22bit做存储，本题只用10bit就够了。

1. 数据的低10位（0-9） 存储原本的数据
2. 往前10位（10-19 ）存储重新排列的数据
3. 取数据的前10位就是答案（右移10位）

`&`：二进制**取位**操作，0x3FF即1023（10进制），1111111111（2进制）

`|`：二进制特定位上的无条件赋值

```java
// 奇偶位
j = i < n ? i*2 : (i-n)*2+1;
// & 取二进制的低10位, | 赋值到前10位
nums[j] |= (nums[i] & 0x3FF) << 10;
nums[j] >> 10
```

**思路二**

题目限制数据范围都是正数，可以用负数做标记

1. 将nums[i]存到应该的位置nums[j]上，并标记为数据的相反数
2. 将nums[j]存到nums[i]上，并根据之前的j计算它应该在的位置，继续交换，标记为相反数
3. 直到所有数都标记为相反数（负数）
4. 转换回正数



# DynamicProgramming动态规划

问题的一般形式：**求最值**

- 如何穷举所有可能
- 存在大量重复计算
  - 时间复杂度爆炸

> 计算机解决问题没有任何特殊技巧，它唯一的解决办法就是穷举，算法设计无非是先思考如何穷举，再追求聪明的穷举
>
> 穷举+剪枝

## DP三要素

- 重叠子问题
- 最优子结构
  - 由子问题的最优结果推导出更大问题的最优结果
  - 要求子问题之间互相独立
- 状态转移方程

## 思考问题

1. base case最简单情况
   1. `dp[0][0]`
2. 问题有哪些状态
   1. 问题和子问题的变量
3. 状态转移
   1. 对于每个**状态**，可以做出哪些**选择**使状态改变（改变变量）
4. 定义dp数组表现选择和状态

## 自底向上

- 递归
  - 自顶向下，由问题答案递归找结果
- DP
  - 自底向上，由base case迭代出问题答案

> 递归时间复杂度：指数级

## 状态压缩



## 0-1背包

- 背包容量c

- n个物品
  - 体积vi
  - 价格pi

### 暴力枚举

对于ni物品

- 选：`knapsack(i-1,c-vi)+pi`
- 不选：`knapsack(i-1,c)`

`knapsack(i,c) = max{knapsack(i-1,c-vi)+pi,knapsack(i-1,c)}`

时间复杂度

- 重复求解子问题
- o(2^n)

### 备忘录

`P[i,c]`

- 记录前i个物品，容量为c的最优解
- `P[0,c] = P[i,0] = 0`

`P[i,c] = max{P[i-1,c-vi]+pi,P[i-1,c]}`

> 将不管选不选的子问题结果记录下来

### 最优解追踪

倒序判断是否选择物品ni

`Rec[i,c]`

- 选：`1`
- 不选：`0`



## 最长递增子序列

Longest Increasing Subsequence：LIS

- 子序列不要求连续
- 时间复杂度：o(n^2)

> 二分搜索：o(nlogn)

1. 状态数组
   1. `dp[i]`：以`nums[i]`结尾的子序列的最长递增子序列的长度
2. base case
   1. `dp[i] = 1`：初始只有自身
3. 状态转移
   1. 由dp[0,...,i-1]推出dp[i]
   2. 对于dp[i]
      1. 需要判断`nums[i]`是否符合递增条件
      2. 可能构成多个递增子序列，找出最大值

> 即对每一个`nums[0]`~`nums[i-1]`判断是否构成递增子序列



**二分搜索**

- 耐心排序

## 最大子数组和

- 子数组要求连续
- 时间复杂度o(n)

> 分治时间复杂度：o(nlogn)

1. 状态数组
   1. `dp[i]`：以`nums[i]`结尾的最大子数组的和
   2. 关于连续的问题，则应该以`nums[i]`结尾
2. base case
   1. `dp[i] = nums[i]`：初始只有自身
3. 状态转移
   1. 由于子数组要求连续，只能由`dp[i-1]`来推出`dp[i]`
   2. 对于dp[i]
      1. 当`dp[i-1] > 0`，`dp[i] = dp[i-1]+nums[i]`
      2. 当`dp[i-1] < 0`，`dp[i] = nums[i]`

> 一开始考虑`nums[i] >,< 0`，后来发现应该是`dp[i-1] >,< 0`
>
> 因为dp数组是以`nums[i]`结尾，所以必须包含，那么要考虑的是是否包含`dp[i-1]`



## 最长公共子序列



## 最长公共子串



## 最长回文子串

[Manacher’s Algorithm](https://medium.com/hackernoon/manachers-algorithm-explained-longest-palindromic-substring-22cb27a5e96f)

**Manacher算法**

- 本质是**对暴力算法的优化**
  - **从左到右一个字符一个字符**来处理字符串
- 时间复杂度：`o(n)`


> 发生中心扩展当且仅当最右回文子串的右边界被向右推，而右边界最多被推`n`次，所以时间复杂度是`o(n)`

### 预处理

对字符串进行预处理，解决奇偶长度问题（全部都是奇数长度）

1. 在所有的空隙（包括首尾）插入分隔符`#`
2. 再在开头插入`$`防止越界，字符串的末尾默认有`'\0'`，不用插入

### 回文半径`RL`

- 一个回文串中最右位置的字符到对称轴字符的距离称为回文半径
- `RL[i]`表示以第`i`个字符为对称轴的回文串的回文半径（`r-i+1`）

> 定义最左位置也可以，但一般对字符串都是从左往右处理

### 回文串长度`RL[i]-1`

拓展后的字符串的最大的`RL[i]-1`正好是原字符串中以`i`字符为对称轴的最长回文串的长度

### 回文串的起始位置

拓展后的字符串的最大`RL[i]`对应的`(i-RL[i])/2`就是原字符串的最大回文串的起始位置

> 在开头加上`$`就是处理`(i-RL[i])<0`的情况

### 求最大的`RL[i]`

需要记录和更新当前最靠右边的回文串

- 对称轴`pos`
- 最右位置`MaxRight`

> `MaxRight = pos + RL[pos] - 1`;

**思想**

先计算出**肯定可以的以i为中心的最短回文字符串的长度**

1. 初始化`pos = MaxRight = 0`

2. 开始遍历拓展后的字符串`i`，找到`i`关于`pos`的对称点`j = 2*pos - i`

   1. 由`pos-j = i-pos`推出`j = 2*pos - i`
   2. 初始化`i=1`(0是`$`)

3. 如果`i < MaxRight`
   1. 如果`RL[j] < MaxRight - i`

      1. 表示以`j`为中心的回文子串包含在以`pos`为中心的最靠右回文子串中
      2. 因为`i`和`j`对称，所以以i为中心的回文子串也包含在以`pos`为中心的最靠右回文子串中
      3. 所以`RL[i] = RL[2*pos - i] = RL[j]`

   2. 如果`RL[j] >= MaxRight - i`

      1. 表示以`j`为中心的回文子串不一定完全包含在以`pos`为中心的最靠右回文子串中

      2. 所以`RL[i] = MaxRight - i`

         > `RL[i]`至少为`MaxRight - i`，因为最右边界外的第一个字符`MaxRight + 1`关于`i`对称的字符不知道是否等于`MaxRight + 1`对应的字符

4. 如果`i > MaxRight`

   1. 字符在回文串外，不知道是否回文，`RL[i] = 1`

5. 所以通过之前遍历得出的的`pos`和`MaxRight`可以得出

   1. `RL[i] = MaxRight > i ? min(RL[2*pos-i], MaxRight-i) : 1`



然后在这个基础上通过**继续向两侧扩展**来计算`RL[i]`，而不用从0开始扩展

对`i`进行中心拓展得到具体的`RL[i]`，如果发现`i`对应的回文串的右边位置超过了`MaxRight`，就要更新对称轴`pos`和最右位置`MaxRight`

- `pos = i`
- `MaxRight = i + RL[i]`

```java
// 马拉车
class Solution {
    public String longestPalindrome(String s) {
        if (s.length() == 0 || s.length() == 1)
            return s;
        // 预处理
        char[] t = preTreat(s);
        // 回文半径
        int[] RL = new int[t.length];
        // 记录最右回文串的pos和MaxRight
        int pos = 0;
        int MaxRight = 0;
        // 记录最大回文长度和起始位置
        int ans = 0;
        int index = 0;
        // 第一位是$
        for(int i=1; i<t.length; i++){
            // 先求RL[i]的下界
            if(i < MaxRight){
                RL[i] = Math.min(RL[2*pos-i], MaxRight-i);
            } 
            else{
                RL[i] = t[i] != '#' ? 2 : 1;
            }
            // 再对剩下部分进行中心扩展,求RL[i]
            while(i-RL[i] >= 0 && i+RL[i] < t.length) {
                if(t[i-RL[i]] == t[i+RL[i]]) {
                    RL[i]++;
                }
                else{
                    break;
                }
            }
            // 更新pos和MaxRight
            if (i+RL[i]-1 > MaxRight) {
                pos = i;
                MaxRight = i + RL[i] - 1;
            }
            // 更新最大回文串长度
            if (RL[i]-1 > ans) {
                ans = RL[i] - 1;
                index = i;
            }
        }
        int start = (index-(ans+1))/2;
        return s.substring(start,start+ans);
    }
    public char[] preTreat(String s){
        StringBuilder sb = new StringBuilder();
        sb.append('$');
        sb.append('#');
        for (int i=0; i<s.length(); i++) {
            sb.append(s.charAt(i));
            sb.append('#');
        }
        return sb.toString().toCharArray();
    }
}   
```











# BackTracking回溯

一种**选优搜索算法**，又称为**试探法**

- 按选优条件向前搜索以达到目标
- 当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择
- 满足回溯条件的某个状态的点称为**回溯点**

**决策树的遍历**

1. 路径：做出的选择
2. 选择列表：当前可选择的选项
3. 结束条件：决策树底层，无法再做选择

> 可以看成是递归调用的一种特殊形式
>
> 递归调用前需要做出选择，递归返回后需要撤销选择

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
	# 核心
    for 选择 in 选择列表:
        # 前序遍历
        做选择，修改选择列表
        backtrack(路径, 选择列表)
        # 后序遍历
        撤销选择，修改选择列表
```

**回溯决策树**

决策树上每个节点都有2个属性

- 路径
- 选择

在遍历时维护每一个节点的属性

> 节点的不同属性称为状态



**前序遍历和后序遍历**

- 前序遍历：进入某个节点之前的时间点执行
  - 做选择
- 后序遍历：离开某个节点之后的时间点执行
  - 撤销选择



## 全排列

`backtrack(first,output)`表示从左往右填到第`first`个位置，当前排列为`output`

1. `first = n`
   1. 找到一个解，添加答案
2. `first < n`
   1. 找到一个没填过的数字
      1. 标记数组`vis`
   2. 填下一个位置`backtrack(first+1,output)`
   3. 回溯时，撤销这一步找的数字，重置标记数组`vis`
   4. 找到另一个没填过的数字...

> `Map.put(nums[i],1)`

**优化**：去掉标记数组

将nums划分成两部分

- 已经用过的数：`[0,first-1]`
- 未用过的数：`[first,n-1]`

使用`[first,n-1]`中的一个数`nums[i]`填入，然后交换`first`和`nums[i]`

