# 算法性质

- 有穷性

- 确定性

- 可行性

- 输入

- 输出


# 算法分析

- 比较算法性能
  - 分析**最坏情况**下算法运行时间
- 输入规模n
  - 时间复杂度 `T(n)`
- **渐进分析**：
  - 忽略`T(n)`的系数和低阶项，**只关注高阶项**
    - 渐进紧确界`O(n)`
    - 渐进上界`θ(n)`
    - 渐进下界`Ω(n)`

> 调和级数：logn

通常最坏情况确定上界，用渐进上界`O(n)`表示时间复杂度



# 数据结构

## 底层存储方式

- **数组**：顺序存储
  - 连续存储，随机访问
  - **必须一次性分配足**
  - 扩容，插入，删除时间复杂度`o(n)`
- **链表**：链式存储
  - **不能随机访问**
  - 存储指针域，消耗更多存储空间
  - 插入，删除时间复杂度`o(1)`

## 基本操作

> **各种数据结构被发明出来的目的就是为了遍历和访问，所以遍历是所有数据结构的基础**

**遍历+访问**：增删改查

- 线性：`for`，`while`
- 非线性：递归

```java
// 链表遍历框架：迭代
for(ListNode p = head; p != null; p = p.next){}
```

# Sort排序

## 排序算法的稳定性

- 待排序的记录序列中可能存在两个或两个以上的关键字相等的记录**，排序结果可能会存在不唯一的情况**
- 排序前后如果相等元素之间**原有的先后顺序不变**，则称所用的排序方法是**稳定的**，反之则称之为**不稳定的**

> 稳定排序可以让第一个关键字排序的结果服务于第二个关键字排序中数值相等的那些数

**稳定性的意义**

- 如果只是简单的进行数字的排序，那么稳定性毫无意义
- 如果排序的内容是一个复杂对象的某一个数字属性，那么稳定性毫无意义
- 如果排序的内容是一个复杂对象的多个数字属性，但是其原本的初始顺序毫无意义，那么稳定性毫无意义

如果排序的内容是一个复杂对象的多个数字属性，**且其原本的初始顺序存在意义**，就需要在二次排序的基础上保持原有排序的意义，这就需要使用到稳定性的算法

## 排序算法的分类

### 比较类和非比较类

- 根据元素是否依靠**与其他元素的比较**来决定元素间的相对次序，以此来区分比较类排序算法和非比较类排序算法

### 内排序和外排序

- 内排序是在排序的整个过程中，**待排序的所有记录全部被放置在内存中**
- 外排序是由于排序的记录个数太多，不能同时放置在内存中，**整个排序过程需要在内外存之间多次交换数据才能进行**

> 对内排序来说，主要受三个方面影响，时间性能，辅助空间，算法的复杂性

## Bubble Sort冒泡排序

比较类排序，稳定排序

> 相等时不交换位置，所以是稳定的

**两两比较相邻记录的元素，如果是反序则交换**

- 每一次冒泡会让至少一个元素移动到它应该在的位置
  - 让最后第i个位置元素有序

- n个元素重复n次后能完成排序

**时间复杂度**

- 最好情况：待排序的数组有序，只需要一次遍历，n-1次比较，时间复杂度为`o(n)`
- 最坏情况：待排序数组逆序，则需要比较`(n-1)+(n-2)+...+2+1 = n*(n-1)/2`，时间复杂度为`o(n^2)`
- 平均情况：需要`n*(n-1)/4`次交换操作，比较操作大于等于交换操作，时间复杂度就是`o(n^2)`

**空间复杂度**

- 只是相邻元素之间的交换操作，只用到了常量级的额外空间，所以空间复杂度为`o(1)`

```java
public int[] Bubble Sort(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 每一次冒泡，后面i个元素有序
        for (int j = 0; j < nums.length - i - 1; j++) {
            // 只比较相邻元素
            if (nums[j] > nums[j+1]) {
                swap(nums[j],nums[j+1]);
            }
        }
    }
    return nums;
}

// 优化，增加标志位
public int[] Bubble Sort(int[] nums) {
    // 记录数组是否有序，有序不用再遍历
    boolean flag = true;
    for (int i = 0; i < nums.length && flag; i++) {
        // 如果没发生交换就有序，下次跳出循环
        flag = false;
        for (int j = 0; j < nums.length - i - 1; j++) {
            if (nums[j] > nums[j+1]) {
                swap(nums[j],nums[j+1]);
                // 发生交换则无序，下次继续判断
                flag = true;
            }
        }
    }
    return nums;
}
```

## Selection Sort选择排序

不稳定排序

每次**从未排序的数组**中选出最小的元素，**将最小的元素和未排序部分的开始元素交换**

- 贪心：每一次决策只看当前，当前最优则全局最优
- 减治：外层循环每一次都能排定一个元素，问题的规模逐渐减少，直到全部解决

> 每次前i个元素有序


**优点**

- 交换次数最少，在交换成本较高的排序任务中，就可以使用选择排序

> 减治思想的典型算法就是二分查找

**时间复杂度**

- 最好情况和最坏情况元素间的**比较次数是一样的**，第i次排序需要n - i次比较，一共是`(n-1)+(n-2)+...+2+1 = n*(n-1)/2`，时间复杂度为`o(n^2)`

**空间复杂度**

- 只用到了常量级的额外空间，所以空间复杂度为`o(1)`

```java
public int[] sortArray(int[] nums) {
    // [0, i)有序
    for (int i=0; i<nums.length-1; i++) {
        // 选择区间[i, nums.length-1]中最小的元素交换
        int minn = i;
        for (int j=i+1; j<nums.length; j++) {
            if (nums[j] < nums[minn]) {
                minn = j;
            }
        }
        if(minn != i){
            swap(nums[i],nums[minn]);
        }
    }
    return nums;
}
```

## Insertion Sort直接插入排序

稳定排序

将数组分成有序和无序两个部分，每次将无序的第一个元素和有序的元素**从后往前**一一对比，将元素插入到对应位置

- 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入

**时间复杂度**

- 最好情况：有序的时候不需要移动元素，每次只需要比较一次即可找到插入位置，时间复杂度为`o(n)`
- 最坏情况：逆序的时候需要比较`2+3+....+n=(n+2)*(n-1)/2`，要移动`3+4+5+....n+1 = (n+4)*(n-1)/2`，时间复杂度为`o(n^2)`

> 插入排序在短数组上的表现很好
>
> - 因为短数组的特点是每个元素离它最终排定的位置都不会太远，所以在小区间内执行排序任务的时候，可以使用插入排序
>
> 在Java排序源码中，小区间也改用插入排序
>
> - `Arrays.sort()`当元素个数少于47时，使用的排序算法就是插入排序
>
> ```java
> // 列表大小等于或小于该大小，将优先于mergeSort使用插入排序
> // 小区间的长度是个超参数，需要测试决定
> private static final int INSERTION_SORT_THRESHOLD = 47;
> 
> if (right - left <= INSERTION_SORT_THRESHOLD) {
>     insertionSort(nums, left, right);
>     return;
> }
> ```

```java
public int[] insertionSort(int[] nums) {
    // 将nums[i]插入到区间[0, i)使之成为有序数组
    // 从1开始
    for (int i=1; i<nums.length; i++) {
        // 先暂存元素，不用逐步交换
        int t = nums[i];
        int j = i;
        while (j > 0 && nums[j-1] > t) {
            // 比较的同时移动
            nums[j] = nums[j-1];
            j--;
        }
        nums[j] = t;
    }
    return nums;
}
```

## Shell Sort希尔排序

不稳定排序

希尔排序是**插入排序**的一种，又称**缩小增量排序**（Diminishing Increment Sort）

- 希尔排序是插入排序的高级变形，是有跨度的插入排序，**这个跨度会逐渐变小直到变为**1，**变为1时基本有序**，这时用到的就是插入排序

**基本有序**

- 小的数基本在前面，大的数基本在后面，不大不小的基本在中间

> 2 1 3 6 4 7 5 8 9

**排序过程**

1. 选择跨度，各个跨度分成的组之间排序
2. 缩小跨度，各个跨度分成的组之间排序
3. 缩小知道跨度为1，各个跨度分成的组之间排序

> 分组跨度称为希尔排序的增量
>
> 增量序列的最后一个增量值必须等于1

**时间复杂度**

- 希尔排序的时间复杂度跟**增量序列的选择有关**，范围为`o(n^(1.3-2))`
- 在此之前的排序算法时间复杂度基本都是`o(n^2)`，希尔排序是突破这个时间复杂度的第一批算法之一

```java
class Solution {
    public int[] sortArray(int[] nums) {
        int increment = nums.length;
        while (increment > 1) {
            // 自己设置增量序列
            increment = increment / 2;
            // 根据增量分组
            for (int i = 0; i < increment; i++) {
                // 插入排序
                for (int j = i + increment; j < nums.length; j += increment) {
                    int temp = nums[j];
                    int k;
                    for (k = j - increment; k >= 0; k -= increment) {
                        if (t < nums[k]) {
                            nums[k+increment] = nums[k];
                            continue;
                        }
                        break;
                    }
                    nums[k+increment] = temp;
                }
            }
        }
        return nums;
    }
}
```



## Quick Sort快速排序

不稳定排序

> 20世纪十大算法之一

**时间复杂度**

- 快排是用递归来实现的，所以快速排序的时间性能取决于**快速排序的递归树的深度**
- 如果每次分区操作，都能**正好把数组分成大小接近相等的两个小区间**，那么此时的**递归树是平衡的，性能也较好**
  - 快排的递归树深度和归并排序一致，每一次分区需要对数组扫描一遍，**做n次比较**，所以最优情况下，快排的时间复杂度是`o(nlogn)`
  - 但是大多数情况下快排不能很均匀的划分数组，**当数组为正序或者逆序时为最坏情况，此时需要递归调用n-1次**，时间复杂度退化到了`o(n^2)`
    - 所以`pivot`最好是随机选取，否则遇到极端测试用例时间复杂度太高

快速排序和归并排序都用到了**分治思想**

- 归并排序是自下而上的，**先处理子问题，然后再合并**，将小集合合并成大集合实现排序
  - **归并排序虽然是稳定的，时间复杂度为`o(nlogn)`的排序算法，但是它是非原地排序算法**
    - 归并排序之所以是非原地排序算法的主要原因是合并函数无法在原地执行，所以归并排序的空间复杂度比较高，是`o(n)`
- 快速排序是由上到下的，先分区，然后再处理子问题
  - 快速排序通过设计巧妙的原地分区函数，**可以实现原地排序，解决了归并排序占用太多内存的问题**


```java
class Solution {
    public int[] sortArray(int[] nums){
        quickSort(nums,0,nums.length-1);
        return nums;
    }

    public void quickSort(int[] nums,int l,int r){
        if(l < r){
            int p = partition(nums,l,r);
            quickSort(nums,l,p-1);
            quickSort(nums,p+1,r);
        }
    }
    public int partition (int[] nums,int l,int r){
			// 选取基数
            int p = nums[l];
            // 记录基数位置，用于交换
            int s = l;
            while(l < r){
                // 基准数选左边，从右边开始找
                // 升序排序，如果是降序排序，则比较方向改变 nums[high] <= pivot
                while(r >= l  && nums[r] >= p){
                    r--;
                }
                while (l < r && nums[l] <= p){
                    l++;
                }
                // 等于说明此轮无交换，直接退出
                if (l >= r) {
                    break;
                }
                // 否则交换不满足的两个数
                swap(nums,l,r);
            }
            // 基准值归位
            swap(nums,l,s);
            return l;
    }
    public void swap(int[] nums,int i,int j){
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
```

## Merge Sort归并排序

稳定排序

**时间复杂度**：`o(nlogn)`

**2路归并排序**

1. 处理待排序数组（不具备局部有序性的特点）
   1. **分解至数组长度为1时天然有序**

2. 递归解决子问题，得到2个有序数组
3. 合并有序子数组
   1. 比较2个有序数组的当前最小元素，将较小者逐一合并 


**递归实现**

```java
public void mergeSort(int[] nums,int l,int r){
    // 子数组长度为1,终止划分
    if(l >= r){
        return;
    }
    // Java里有更优的写法，在l和r都是大整数时，即使溢出结论依然正确
    // int mid = (l + r) >>> 1;
    int mid = l + (r - l) / 2;
    // 划分区间为[l,mid]和[mid+1,r]
    mergeSort(nums, l, mid);
    mergeSort(nums, mid+1, r);
    int i = l;
    int j = mid + 1;
    int[] tmp = new int[r-l+1];
    int k = 0;
    // Merge
    while(i<=mid && j<=r){				
        if(nums[i] <= nums[j]){
            tmp[k] = nums[i];
            i++;
        }
        else{
            tmp[k] = nums[j];
            j++;
        } 
        k++;
    }
    // 未合并的部分直接放在最后
    while(i <= mid){
        tmp[k] = nums[i];
        k++;
        i++;
    }
    while(j <= r){
        tmp[k] = nums[j];
        k++;
        j++;
    }
    // 复制从t的0开始，复制到nums的l开始，长度为r-l+1
    System.arraycopy(tmp,0,nums,l,r-l+1);
}
```

**迭代实现**

- 主要是计算每次操作的子集合的区间对应的索引，其余操作是相同的

```java
class Solution {
    public int[] sortArray (int[] nums) {
        // l代表集合大小:1，2，4，8，16...
        int l = 1;
        int len = nums.length;
        while (l < len) {
            mergePass(nums,l,len);
            l *= 2;
        }
        return nums;
    }
    public void mergePass (int[] nums, int l, int len) {
        int i;
        for (i=0; i<len-2*l; i+=2*l) {
            // 合并
            merge(nums,i,i+l-1,i+2*l-1);
        }
        // 合并最后两个序列
        if (i+l < len) {
            merge(nums,i,i+l-1,len-1);
        }
    }
    public void merge (int[] nums,int l, int mid, int r) {
        int[] t = new int[r-l+1];
        int i = l;
        int j = mid + 1;
        int k = 0;
        while (i <= mid && j <= r) {
            if (nums[i] <= nums[j]) {
                t[k] = nums[i];
                i++;
            } else {
                t[k] = nums[j];
                j++;
            }
            k++;
        }
        while(i <= mid){
            t[k] = nums[i];
            i++;
            k++;
        }
        while(j <= r){
            t[k] = nums[j];
            j++;
            k++;
        }
        System.arraycopy(t,0,nums,l,r-l+1);
    }
}
```

### [剑指51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

利用归并排序的合并过程，在合并2个有序的数组判断逆序对

- 当左数组的当前元素小于右数组当前元素时，正常合并
- **当左数组的当前元素大于右数组当前元素时，左数组的后续元素都会大于右数组的当前元素，即构成逆序对**
  - **剪枝**：当左数组的最大元素小于右数组最小元素时，全部有序，无逆序对，直接返回

时间复杂度：`o(nlogn)`

```java
class Solution {
    public int reversePairs(int[] nums) {
        int ans = mergeSort(nums,0,nums.length-1);
        return ans;
    }
    public int mergeSort(int[] nums,int l, int r){
        if(l >= r){
            return 0;
        }
        int mid = l + (r-l)/2;
        int t1 = mergeSort(nums,l,mid);
        int t2 = mergeSort(nums,mid+1,r);
        int ans = t1+t2;
        // 有序直接合并
        if(nums[mid] < nums[mid+1]){
            return ans;
        }
        int i = l;
        int j = mid+1;
        int k = 0;
        int[] t = new int[r-l+1];
        while(i <= mid && j <= r){
            if(nums[i] <= nums[j]){
                t[k] = nums[i];
                i++;
            }
            else{
                t[k] = nums[j];
                j++;
                // 子区间有序,nums[i]以及后面所有数和nums[j]都构成逆序对
                ans += mid-i+1;
            }
            k++;
        }
        while(i <= mid){
            t[k] = nums[i];
            i++;
            k++;
        }
        while(j <= r){
            t[k] = nums[j];
            j++;
            k++;
        }
        System.arraycopy(t,0,nums,l,r-l+1);
        return ans;
    }
}
```

## 多路归并

**外排序**

- 将一个大文件分成M个小文件，**每个小文件是有序的**
- **对应在内存中使用M个优先队列，每个队列从对应编号的文件中读取TopN条记录**
- 然后从M路队列中各取一个数字进入中转站队列，**并将该数字打上队列编号标记**，从中转站出来的最小数字就是最后要排序的数字之一
- 因为该数字上有队列编号，所以可以通知**对应编号的队列继续出数字进入中转站队列**
- **中转站一直保存了M个记录**，当中转站中的所有数字都出队完毕，则外排序结束

> 内排序在内存中进行，归并排序就是2路归并

# 水题

## [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)

- int范围：`-2147483648~2147483647`（10位数）

- 在循环中判断溢出：`if ((ans*10) / 10 != ans)`

  - 当`ans*10`未溢出时`ans*10`个位为0，故`ans*10 + x%10`没有进位
    - 但并不是没有进位就不溢出，而是末位是正数不能大于7，是负数不能小于-8 
    - 由于**原数在int范围内，当它是10位数时才可能溢出，此时第一位一定是1或2** ，那么反转最后一位也就是1或2，那么`ans * 10`加上它也不会溢出

> `(ans * 10)`溢出的时候Java可以暂存，C不可以

```java
public int reverse(int x) {
    int sum = 0;
    while (x!=0) {
        if (sum * 10 / 10 != sum) {
            return 0;
        }
        // 不会有进位
        sum = sum * 10 + x % 10;
        x = x / 10;
    }
    if (x >= 0) {
        return sum;
    } 
    else {
        return -sum;
    }
}
```

## [9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

考虑只反转数字的一半：**如何判断位数到一半了**，奇偶是否有区别

- 当**原始数字小于或等于反转后的数字**时，表示已经处理了一半位数的数字
- 奇位数的中间位数字不影响回文，所以可以统一处理


```java
public boolean isPalindrome(int x) {
    if (x == 0) {
         return true;
    }
    if (x < 0 || x % 10 == 0) {
        // 10回文是01
        return false;
    }
    int reversed = 0;
    // 当reversed大于等于x时候结束
    while (x > reversed) {
        reversed = reversed * 10 + x % 10;
        x /= 10;
    }
    // 偶数位数x = reversed，奇数位数x = reversed / 10
    return x == reversed || x == reversed / 10;
}
```

# Array数组

## 稀疏数组

当一个数组中**大部分元素都是0或同一个值**，就可以用稀疏数组来保存

稀疏数组可以看做是普通数组的**压缩**

- 数组中存在大量的无效数据，占据了大量的存储空间，真正有用的数据很少
- 压缩存储可以节省存储空间以避免资源浪费，在数据序列化到磁盘时，压缩存储还可以提高IO效率

> 普通数组是指**无效**数据量**远大于**有效数据量的数组

```bash
# 普通数组
0 0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0

# 稀疏数组
# 11行，11列，2个值
# 第一行，第二列，值为1
# 第二行，第四列，值为2
11 11 2
1  2  1
2  4  2
```

### 存储稀疏数组

#### 普通存储

1. 记录数组**行列数**，**元素个数**（除大量重复元素外）
2. 把不同元素的**行列和值**记录在一个小规模的数组中（**固定3列**）

```java
// n个元素
int[][] array = new int[n+1][3];
array[k][0] = i;
array[k][1] = j;
array[k][2] = data;
```

#### 链式存储

**普通链式**

- 把不同元素的**行列和值**记录在一个节点的数据域中
- （1，2，1）-（2，4，2）

**行式链式**

- 将不同元素按照索引的方式存储
- 1-（1，2，1）
- 2-（2，4，2）

**十字链式**

- 由两个链表模拟行和列
- 0 1 2 3 4
- 1   1
- 2       2
- 3
- 4

### 还原普通数组

```java
// n个元素
int[][] rarray = new int[array[0][0]][array[0][1]];
// i从1开始，第0行是数组信息
rarray[array[i][0]][array[l][1]] = array[i][2]
```



## [面试题17.10. 主要元素](https://leetcode-cn.com/problems/find-majority-element-lcci/)

数组中一个数出现的次数超过数组长度的一半

- 时间复杂度：`o(n)`
- 空间复杂度：`o(1)`

**思想**

- **统计学上的中位数**：有一半的数比它大，有一半的数比它小
  - 所以在**排序后出现在数组中间的数字**一定就是那个数
- **摩尔投票法**：如果它出现的次数比其他所有数出现的次数都多
  - 所以用其他数和它消除，最后还会剩下它
  - **在第一遍消除遍历后应该再进行一次遍历以统计第一次算法遍历的结果出现的次数**来确定其是否为众数，因为如果没有主要元素，第一次消除最后剩下的结果可能就是无效的随机元素

> 暴力：哈希表

```java
public int majorityElement(int[] nums) {
    int t = 0;
    int tn = 0;
    for(int i=0; i<nums.length; i++){
        if(tn == 0){
            t = nums[i];
            tn++;
        }
        else{
            if(nums[i] != t){
                tn--;
            }
            else{
                tn++;
            }
        }
    }
    // 仅靠剩余的一个元素并不能判断是否超过一半数，因为可能是其他数相消了刚好剩下它
    // 但如果存在这个元素，那一定是剩下的这个元素
    int ans = 0;
    for(int i=0; i<nums.length; i++){
        if(nums[i] ==  t){
            ans++;
        }
    }
    if(ans > nums.length/2){
        return t;
    }
    else{
        return -1;
    }
}
```



# BinarySearch二分搜索

- `else if`
  - 将所有的条件写成`else if`，不使用`else`
- `mid = l + (r - l) / 2`
  - 防止`left`和`right`太大直接相加导致溢出

```java
int l = 0;
int r = nums.length-1;
while(l <= r){
    int mid = l + (r - l) / 2;
    if(nums[mid] > target){
        r = mid - 1;
    }
    else if(nums[mid] < target){
        l = mid + 1;
    }
    else if(nums[mid] == target){
        return mid;
    }
}
return -1;
```

## 搜索区间

**搜索闭区间[left,right]**

- 当没有搜索到目标值时，`left = right+1 (left > right)`循环时终止
- 此时**区间为空**，返回-1即可

```java
// 1.
int left = 0;
int right = nums.length-1;
while(left <= rigth){
    
}
```

**搜索开区间[left,right)**

- 当没有搜索到目标值时，`left = right`时循环终止
- 此时**区间非空**，是`[right,right]`，所以还需要单独判断`nums[right]`

> right = nums.length则不用单独判断

```java
// 2.
int left = 0;
int right = nums.length-1;
while(left < rigth){
    
}
```



**left/right**

当`nums[mid]`不满足条件，继续搜索计算区间时

**搜索闭区间[left,right]**

`mid`已经包含在搜索区间中了，下一步搜索

- `[left,mid-1]`
- `[mid+1,right]`

所以两个区间都要剔除`mid`

```java
left = mid+1;
right = mid-1;
```

**搜索开区间[left,right)**

右边是开区间，包括`left`，不包括`right`，所以下一步搜索

- `[left,mid)`
  - 需要剔除`mid`
- `[mid,right)`
  - 不需要剔除`mid`

```java
left = mid+1;
right = mid;
```



## 左侧边界

其实就是在**找到值时继续向左搜索值**

- **左侧边界的意义**
  - 排序数组中，小于`nums[l]`的数有`l`个
- **return left**
  - 闭区间时，最后搜索到值后是在`left = right + 1`结束，所以`left`的取值范围是`[0,nums.length]`
  - 所以需要单独判断越界：`left = nums.length`
  - 并且因为寻找左侧边界时只是一直在缩小区间上界范围，所以还需要判断是否找到了值：`nums[left] = target`

```java
int l = 0;
int r = nums.length-1;
while(l <= r){
    int mid = l + (r - l) / 2;
    if(nums[mid] >= target){
        r = mid - 1;
    }
    else if(nums[mid] < target){
        l = mid + 1;
    }
}
if(l >= nums.length || nums[l] != target){
    return -1;
}
return l;
```



## 右侧边界

```java
int l = 0;
int r = nums.length-1;
while(l <= r){
    int mid = l + (r - l) / 2;
    if(nums[mid] > target){
        r = mid - 1;
    }
    else if(nums[mid] <= target){
        l = mid + 1;
    }
}
if(r < 0 || nums[r] != target){
    return -1;
}
return r;
```

## [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

二分的题目重点找**两段性，而不是单调性**

- **某一段数满足一个性质，另一段数不满足这个性质**

本题原数组按升序排列，所以旋转后，**有一段数大于旋转点数值，另一段数则小于旋转点数值**

- 旋转点数即`nums[0]`

```java
public int findMin(int[] nums) {
    int l = 0;
    int r = nums.length-1;
    if(nums[l] < nums[r]){
        return nums[l];
    }
    int t = nums[l];
    while(l < r){
        int mid = l + (r-l)/2;
        if(nums[mid] < t){
            r = mid;
        }
        else {
            l = mid+1;
        }
    }
    return nums[l];
}
```

## [154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

和153不同，本题元素并不唯一

- 所以当在旋转隔开了相同的值后，就无法满足两段性

- 所以可以删除最后的相同元素来保证剩下元素的两段性

```java
```









# LinkedList链表

```c
struct ListNode {
    int val;
    struct ListNode *next;
};

// malloc stdlib.h
struct ListNode* pre = (struct ListNode*)malloc(sizeof(struct ListNode));
```

```java
public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}
```

## 链表的遍历

链表的递归遍历其实和二叉树的递归遍历相似，所以也有前序遍历和后序遍历

- 前序遍历就是进入递归前处理
- 后序遍历就是完成递归后处理
  - 想**倒序遍历链表**，就可以在后序遍历位置操作


```java
void traverse(ListNode head){
    // 前序遍历代码
    traverse(head.next);
	// 后序遍历代码
}
```

## 模拟链表

使用两个数组来模拟链表的数据存储和位置关系

- `data`数组存放数据
- `right`数组存放数据位置关系
  - `right[i]`表示`data`数组的第`i`个元素的**右边一个（下一个）元素**的位置
- 添加元素
  - 新数据直接顺序存放在`data`数组末尾，不用考虑位置关系
  - 通过`right`数组遍历`data`数组，找到应该存放的位置，修改`right`数组

```java
// 初始化
for(int i=0; i<n; i++){
    right[i] = i+1; 
}
right[n] = -1;

// data = {2,3,5,8,9,10,18,26,32}，则right = {1,2,3,4,5,6,7,8,-1}，
// right[0] = 1,表示data[0]元素的右边是data[1]元素，最后一位为-1变表示右边没有元素，如果时循环链表则指向第一个元素1

// 添加元素x
data[n] = x;
// 遍历right数组
int t = 0;
while(t != -1){
    // index是当前元素的下一个元素的位置值
    int index = right[t];
    if(data[index] > data[n]){
        // x小于data[index]，所以x应该插入在data[index]前
        right[n] = index;
        // 当前元素的下一个元素就是插入元素
        right[t] = n;
        break;
    }
    t = right[t];
}
```

## [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

**删除**：只要将后续点集体往前移动一位，则下一个点的值就会覆盖要删除点的值，这个点就不在了

> 只适用于非末尾节点

```java
node.val = node.next.val;
node.next = node.next.next;
```

## [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

**哨兵节点**

- 当要删除的一个或多个节点位于**链表头部**
- 因为删除操作需要通过`next`指针域判断，为了方便操作，需要定位新的链表头指针`pre`

**双指针**

- 正常`cur`指针从`head`开始遍历整个链表
- 哨兵节点`pre`指针则负责删除节点，**即将`pre`指针的下一个元素指向要删除元素的下一个元素**

```java
public ListNode removeElements(ListNode head, int val) {
    // 哨兵节点
    ListNode p = new ListNode();
    p.next = head;
    ListNode pre = p;
    while(head != null){
        if(head.val == val){
            // 删除当前节点，哨兵节点不移动
            head = head.next;
            p.next = head;
        }
        else{
            // 2个指针同时向后移动
            head = head.next;
            p = p.next;
        }

    }
    return pre.next;
}
```

## [剑指22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)


- **栈**：倒序天然适合栈操作
- **双指针**：快慢指针
- 快指针先走k步，然后快慢两个指针一起走直到快指针为空，因为两个指针相距k步，慢指针刚好到达倒数第k个节点

> **模n同余**：给定一个正整数m，如果两个整数a和b满足 a-b 能够被m整除，那么就称整数a与b对模m同余，记作a≡b(mod m)。对模m同余是整数的一个等价关系

```java
public ListNode getKthFromEnd(ListNode head, int k) {
    ListNode former = head;
    ListNode latter = head;
    for(int i=0; i<k; i++){
        former = former.next;
    }
    while(former != null){
        former = former.next;
        latter = latter.next;
    }
    return latter;
}
```

## [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

**哨兵节点**

- 要删除的节点可能位于**链表头部**，需要定位新的链表头指针`pre`

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode fast = head;
    for(int i=0; i<n; i++){
        fast = fast.next;
    }
    ListNode slow = head;
    ListNode pre = new ListNode();
    pre.next = head;
    ListNode p = pre;
    while(fast != null){
        fast = fast.next;
        p = p.next;
    }
    p.next = p.next.next;
    return pre.next;
}
```

## [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

**双指针**：快慢指针

- 慢指针一次走1步，快指针一次走2步，当快指针走完的时候慢指针到达链表中间位置
- 当链表长度为奇数时，`fast`指向**最后一个节点**，当链表长度为偶数时，`fast`指向`null`


```java
public ListNode middleNode(ListNode head){
    // 注意边界判断
    ListNode fast = head;
    ListNode slow = head;
    while(fast != null && fast.next != null){
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
```

## [2095. 删除链表的中间节点](https://leetcode-cn.com/problems/delete-the-middle-node-of-a-linked-list/)

**哨兵节点**

```java
public ListNode deleteMiddle(ListNode head) {
    if(head.next == null){
        return null;
    }
    ListNode fast = head;
    ListNode slow = head;
    ListNode pre = new ListNode();
    pre.next = head;
    while(fast != null && fast.next != null){
        fast = fast.next.next;
        slow = slow.next;
        pre = pre.next;
    }
    pre.next = slow.next;
    return head;
}
```

## [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

**最简单的办法**：将原始链表反转存入一条新的链表，然后比较这两条链表是否相同

### 递归

**时间复杂度**：`o(n)`

**空间复杂度**：`o(n)`

- 定义一个节点从前往后遍历链表
- 利用递归实现链表的后序遍历，从后往前遍历链表
  - 利用递归函数的堆栈

```java
// 从前往后
ListNode left;
public boolean isPalindrome(ListNode head) {
    left = head;
    return traverse(head);
}
public boolean traverse(ListNode right){
    if(right == null){
        return true;
    }
    boolean ans = traverse(right.next);
    // 后序遍历，从后往前，传递比较结果
    ans = ans && (right.val == left.val);
    left = left.next;
    return ans;
}
```

### 迭代

**时间复杂度**：`o(n)`

**空间复杂度**：`o(1)`

**反转后半部分**

1. 双指针遍历找到链表的中间节点，**奇数长度的链表需要跳过中间节点**，得到后半部分链表
2. 将后半部分链表反转，再和前半部分链表比较

> 正常判断回文是不需要考虑奇偶的

```java
public boolean isPalindrome(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    while(fast != null && fast.next != null){
        fast = fast.next.next;
        slow = slow.next;
    }
    // 奇数长度需要跳过中点
    if(fast != null){
        slow = slow.next;
    }
    ListNode pre = null;
    ListNode cur = slow;
    ListNode next = slow;
    while(cur != null){
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    // 反转后的pre就是后半部分链表的头节点
    while(pre != null){
        if(pre.val != head.val){
            return false;
        }
        pre = pre.next;
        head = head.next;
    }
    return true;
}
```

**反转前半部分**

- 双指针遍历找到链表的中间节点，同时使用慢指针反转前半部分链表
- 并且由于反转会慢一步，所以链表长度是奇偶不会影响反转的链表长度
- 但是slow指针会停在中间位置，所以如果链表长度是奇数，`slow`指针需要跳过中点

```java
public boolean isPalindrome(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    // 用慢指针反转前半部分链表
    ListNode next = null;
    ListNode pre = null;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        next = slow.next;
        slow.next = pre;
        pre = slow;
        slow = next;
    }
    // 奇数长度需要跳过中点
    if(fast != null){
        slow = slow.next;
    }
    while(pre != null){
        if(pre.val != slow.val){
            return false;
        }
        pre = pre.next;
        slow = slow.next;
    }
    return true;
}
```

## [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

**双指针**：快慢指针

- 如果链表存在环，**快指针最后会在环中追上慢指针**
- 慢指针如果走了`k`，则快指针走了`2k`，差距`k`就是环的长度`l`的**整数倍**。因为可能慢指针还没进入环的时候，快指针已经在环中循环n圈了，即`k = n*l`

```java
public boolean hasCycle(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if(fast == slow){
            return true;
        }
    }
    return false;
}
```

## [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

**双指针**：快慢指针

1. 当快指针追到慢指针时，加速慢指针走了`k`，则快指针走了`2k`，差距`k`就是环的长度`l`的整数倍
2. 假设环的入口点和相遇点相距`m`，因为慢指针走了`k`，所以链表头节点`head`和入口点相距`k-m`
3. 即慢指针从入口点走了`m`，所以慢指针再走`k-m`就相当于从入口处走了`k`，因为`k`是环长`l`的整数倍，即绕了`n`圈回到了入口处
4. 而`head`走`k-m`也会到达入口，所以相遇点就是环的入口

```java
public ListNode detectCycle(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    while(fast != null && fast.next != null){
        fast = fast.next.next;
        slow = slow.next;
        if(fast == slow){
            fast = head;
            while(fast != slow){
                fast = fast.next;
                slow = slow.next;
            }
            return fast;
        }
    }        
    return null;
}
```



## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

### 递归

1. 递归最终的返回值应该是**反转部分的链表的头节点**，即最后返回的一定是**整个链表的末尾节点**，所以最后一个节点就是递归结束的节点，递归结束条件是`head.next = null`
   1. 最后一个节点只用于返回，倒数第二个节点是最后执行递归部分的节点

2. 递归返回的结果只是反转后的头节点，所以反转的处理是每一个`head`和`head.next`之间的操作
   1. `head.next`指向`head`实现反转，然后将`head`指向`null`，因为最后的节点要指向`null`


```java
// 1->2->3->4->5->null
// 1 2->3-> null<-4<-5
// null<-1<-2 3->4->5->null
// null<-1<-2<-3 4->5->null
// null<-1<-2<-3<-4 5->null
public ListNode reverseList(ListNode head) {
    // 鲁棒性，可能是空链表
    if(head.next == null || head == null){
        return head;
    }
    ListNode ans = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return ans;
}
```

### 迭代

**反向法**

1. 依次遍历每一个节点，将其**指向前面一个节点**形成反转
2. 第一个节点需要指向`null`，需要定义**哨兵节点**

**插入法**

1. 依次遍历每一个节点，每次将其**从链表中拿出来插入到前面一个节点的前面**
2. 需要定义哨兵节点，依次插入到哨兵节点和头节点的中间

```java
// 反向法
// 1->2->3->4->5->null
// null<-1 2->3->4->5->null
// null<-1<-2 3->4->5->null
// null<-1<-2<-3 4->5->null
// null<-1<-2<-3<-4 5->null
// null<-1<-2<-3<-4<-5
public ListNode reverseList(ListNode head) {
    if(head == null || head.next == null){
        return head;
    }
    ListNode pre = null;
    ListNode cur = head;
    ListNode next = head;
    while(cur != null){
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}

// 插入法
// 1->2->3->4->5->null
// pre->2->1 3->4->5->null
// pre->3->2->1 4->5->null
// pre->4->3->2->1 5->null
// pre5->->4->3->2->1->null
public ListNode reverseList(ListNode head) {
    if(head == null || head.next == null){
        return head;
    }
    ListNode pre = new ListNode();
    pre.next = head;
    ListNode cur = head;
    ListNode next = null;
    // 判断cur.next
    while(cur.next != null){
        next = cur.next;
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }
    return pre.next;
}
```

## [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

**前置问题**：反转前n个节点

- 即最后反转的链表尾节点（原链表头节点）不指向`null`

**迭代**

```java
// 插入法
// 1->2->3->4->5->null
// pre->2->1 3->4->5->null
// pre->3->2->1 4->5->null
// pre->4->3->2->1 5->null
// pre5->->4->3->2->1->null
public ListNode reverseN(ListNode head,int n) {
    if(head == null || head.next == null){
        return head;
    }
    ListNode pre = new ListNode();
    pre.next = head;
    ListNode cur = head;
    ListNode next = null;
    // 判断cur.next
    while(cur.next != h){
        next = cur.next;
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }
    return pre.next;
}
```



### 递归

- 当问题的`l`是1时，转换为反转前`r`个节点

```java
// 相对于head.next是递归l-1,r-1

public ListNode reverseBetween(ListNode head, int left, int right) {
    if(left == 1){
        return reverseN(head,right);
    }
    head.next = reverseBetween(head.next,left-1,right-1);
    return head;
}
// 可以把null看成剩余的头节点
// 利用m=1找到tail
// 2-3-4-5反转2-3-4 = 4-3-2-5
// 2(3)-3(2)-4(1)得到反转后要接的节点5，返回4
// 3接到4后面，3后面接5 = 2(next=3) 4-3-5
// 2接到3后面，2后面接5 = 4-3-2-5
// 返回4
ListNode tail;
public ListNode reverseN(ListNode head,int m){
    if(m == 1){
        tail = head.next;
        return head;
    }
    ListNode last = reverseN(head.next,m-1);
    head.next.next = head;
    head.next = tail;
    return last;
}
```

### 迭代

```java
public ListNode reverseBetween(ListNode head, int left, int right) {
    ListNode pre = new ListNode();
    pre.next = head;
    ListNode ans = pre;
    ListNode h = head;
    // 获取需要反转的链表的头节点h，pre用于连接反转后的链表
    for(int i=0; i<left-1; i++){
        pre = pre.next;
        h = h.next;
    }
    ListNode cur = h;
    // 获取需要反转的链表的最后一个节点p
    for(int i=0; i<right-left+1; i++){
        h = h.next;
    }
    ListNode p = h;
    // 反转链表h->p
    ListNode next = null;
    while(cur != h){
        next = cur.next;
        cur.next = p;
        p = cur;
        cur = next;
    }
    // 当前头节点是p
    pre.next = p;
    return ans.next;
```

## [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)



## [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

如果两个链表存在交点，那么交点后面部分的链表是一样的，所以考虑如果遍历交点前面的部分，使得两个链表能够**同时达到交点**

- 在当前链表节点为空时，再去遍历另一条链表，这样双方都遍历`lenA+lenB`长度的链表

- 当两个指针同时为`null`时也判定是相等

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    ListNode ha = headA;
    ListNode hb = headB;
    while(headA != headB){
        // 所以是判断headA = null，而不是headA.next，不然会死循环
        headA = headA == null ? hb : headA.next;
        headB = headB == null ? ha : headB.next;
    }
    return headA;
}
```

## [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

### 递归

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    if(list1 == null){
        return list2;
    }
    if(list2 == null){
        return list1;
    }
    if(list1.val < list2.val){
        list1.next = mergeTwoLists(list1.next,list2);
        return list1;
    }
    else{
        list2.next = mergeTwoLists(list1,list2.next);
        return list2;
    }
}
```

### 迭代

**归并排序**

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    ListNode pre = new ListNode();
    ListNode h = pre;
    while(list1 != null && list2 != null){
        if(list1.val < list2.val){
            pre.next = list1;
            list1 = list1.next;
        }
        else{
            pre.next = list2;
            list2 = list2.next;
        }
        pre = pre.next;
    }
    pre.next = list1 == null ? list2: list1;
    return h.next;
}
```

## [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

**时间复杂度**：`o(nlogn)`

**空间复杂度**：`o(1)`

**归并排序**

- 对于链表来说，归并排序的划分就是使用快慢指针来找到中点切分
- 归并排序的合并就是从单独节点开始，合并两个有序链表

```java
```





## [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

**时间复杂度**：`o(n)`

**空间复杂度**：`o(1)`

只对单链表进行节点交换：`l0->ln->l1->ln-1`...

1. 找到链表中点，切分链表
2. 反转链表
3. **合并链表**：因为划分后的两个链表长度相差不超过1，因此直接合并即可

```java
public void reorderList(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    ListNode pre = new ListNode();
    pre.next = head; 
    while(fast != null && fast.next != null){
        fast = fast.next.next;
        slow = slow.next;
        pre = pre.next;
    }
    if(fast != null){
        slow = slow.next;
        pre = pre.next;
    }
    // 划分链表
    pre.next = null;
    // 反转链表
    pre = null;
    ListNode cur = slow;
    ListNode next = slow;
    while(cur != null){
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    // 合并链表
    ListNode p = head;
    while(p != null && pre != null){
        ListNode t1 = p.next;
        ListNode t2 = pre.next;
        p.next = pre;
        pre.next = t1;
        p = t1;
        pre = t2;
    }
}
```

# Stack/Queue栈和队列

> 栈和队列在操作系统中的应用场景：递归和调度

## Queue队列

```c
struct queue {
    int data[1000];
    int head;
    int tail;
};
```

### PriorityQueue优先队列

**小根堆**：小的在前，大的在后

`Queue<Integer> pq = new PriorityQueue<>();`

**时间复杂度**

- 从优先队列中取最小值为`o(1)` 
- 往优先队列中添加元素为`o(logn)`

#### [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)

**时间复杂度**：`o(nlogn)` 

```java
public int nthUglyNumber(int n) {
    int[] nums = new int[]{2,3,5};
    // 优先队列
    // 包装类 long-Long
    Queue<Long> pq = new PriorityQueue<>();
    Set<Long> set = new HashSet<>();
    // 必须加l或L
    pq.offer(1l);
    set.add(1l);
    for(int i=0; i<n; i++){
        long t = pq.poll();
        if(i == n-1){
            return (int)t;
        }
        for(int num : nums){
            long s = t * num;
            if(!set.contains(s)){
                set.add(s);
                pq.add(s);
            }
        }
    }
    return -1;
}
```



## Stack栈

```c
struct stack {
    int data[1000];
    int top;
};
```

### [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

- 中缀表达式：正常使用的表达式，运算符在两个操作数的中间（a+b）由优先级判断顺序

- 后缀表达式（逆波兰式）：**运算符跟在两个操作数后**（abcde/-f+）

  运算规则：每个运算符和在它之前出现且紧靠它的两个操作数构成一个最小表达式

  **在堆栈中括号的优先级最低**

- 前缀表达式（波兰式）：**运算符在两个操作数前**（+ab-c/def）

  运算规则：连续出现的两个操作数和它们之前且紧靠它们的运算符构成一个最小表达式



 



# BinaryTree二叉树

**递归**：用自身定义自身

- 递归边界
- 递归式：和大问题性质相似的小问题

## 二叉树

- 严格区分左右子树
- 叶子节点数为n，度为2的节点数为m，则**n=m+1**

> 和度为2的树的最主要区别

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### N叉树

```java
class TreeNode{
    int val;
    TreeNode[] children;
}
```

### 二叉链表

```c++
struct TreeNode{
    int data;
    TreeNode* lchild;
    TreeNode* rchild;
};

TreeNode* root = NULL;
```

### 静态二叉链表

**用长度为二叉树节点个数的数组实现**

- 所有动态生成的节点都用**数组中的节点**
- 使用**数组下标**访问二叉树的节点

```c++
struct TreeNode{
    int data;
    int lchild;
    int rchild;
} Node[maxn];
```

### 特殊的二叉树

- **斜树**
  - 左斜树
  - 右斜树
- **满二叉树**（完美）
  - 所有分支节点都存在左右子树
  - 所有叶子节点都在同一层
- **完全二叉树**
  - 所有节点和同样深度的满二叉树的节点一一对应
  - **叶子节点只能出现在最下面两层**
    - 最下层的叶子节点一定在**左边连续位置**
    - 倒数第二层的叶子节点一定在右边连续位置
  - 不存在只有右子树的节点，度为1一定是只有左子树
  - 同样节点的数的二叉树，**完全二叉树深度最小**（n个节点深度为**向下取整(logn)+1**）

> 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树

### 完全二叉树的存储

可以使用长度为**2<sup>n</sup>**的数组存储所有节点

- n为完全二叉树的最大高度，即数组长度为完全二叉树的**节点总数+1**
- 下标从1开始，`nums[1]`存放根节点
- 数组中**存放完全二叉树的节点顺序刚好是层序遍历的顺序**

假设完全二叉树的任一节点编号为n

- 节点左孩子编号为**2*n**
- 节点右孩子编号为**2*n+1**

## 二叉树的插入

插入位置就是查找失败的位置，**建树就是不断向二叉树插入节点**

## 二叉树的遍历

### 深度优先搜索DFS

左子树一定先于右子树遍历

- 前序遍历preorder
- 中序遍历inorder
- 后序遍历hostorder

### 广度优先搜索BFS

- 层序遍历：非递归，**队列实现**


```java
Deque<TreeNode> q = new LinkedList<>();
q.offerLast(root);
while(!q.isEmpty()){
    TreeNode node = q.pollFirst();
    // 层序遍历
    t.add(node.val);
    if(node.left != null){
        q.offerLast(node.left);
    }
    if(node.right != null){
        q.offerLast(node.right);
    }
}
```

**分层遍历**

```java
List<List<Integer>> ans = new LinkedList<>();
Deque<TreeNode> q = new LinkedList<>();
q.offerLast(root);
while(!q.isEmpty()){
    List<Integer> t = new LinkedList<>();
    // 使用i初始化，保证不会因为q.size()改变而出错
    for(int i=q.size(); i>0; i--){
        TreeNode node = q.pollFirst();
        t.add(node.val);
        if(node.left != null){
            q.offerLast(node.left);
        }
        if(node.right != null){
            q.offerLast(node.right);
        }
    }
    ans.add(t);
}
```

## 二叉树的还原

**根据遍历结果还原二叉树**，即建立二叉树

- **必须知道中序遍历才能还原二叉树**
- 前序，后序，层序遍历可以获得**根节点**，而中序遍历可以根据根节点来区分**左右子树**

> 必须保证所有节点值不相同

**还原过程**

前序遍历preorder：[p<sub>1</sub>，p<sub>2</sub>...p<sub>k</sub>，p<sub>k+1</sub>...p<sub>n</sub>]

中序遍历inorder：[i<sub>1</sub>，i<sub>2</sub>...i<sub>k-1</sub>，i<sub>k</sub>，i<sub>k+1</sub>...i<sub>n</sub>]

1. 根据前序遍历得出p<sub>1</sub>是根节点root
2. 在中序遍历中找到**i<sub>k</sub>=p<sub>1</sub>**，根据i<sub>k</sub>划分左右子树
3. 根据中序遍历得出左子树节点个数**n=k-1**
4. 根据n得出在前序遍历中左子树的区间为[p<sub>2</sub>,p<sub>k</sub>]，右子树区间为[p<sub>k+1</sub>,p<sub>n</sub>]
5. 根据n得出在中序遍历中左子树的区间为[i<sub>1</sub>,i<sub>k-1</sub>]，右子树区间为[i<sub>k+1</sub>,i<sub>n</sub>]
6. 根据左，右子树的前，中序遍历递归还原二叉树

> 子树的前序遍历区间是[p<sub>l</sub>,p<sub>r</sub>]，中序遍历区间是[i<sub>l</sub>,i<sub>r</sub>]，且i<sub>k</sub>=p<sub>l</sub>，则左子树节点个数n=k-i<sub>l</sub>
>
> 左子树的前序遍历区间为[p<sub>l+1</sub>,p<sub>l+n</sub>]，左子树的中序遍历区间为[i<sub>l</sub>,i<sub>k-1</sub>]
>
> 右子树的前序遍历区间为[p<sub>l+n+1</sub>,p<sub>r</sub>]，左子树的中序遍历区间为[i<sub>k+1</sub>,i<sub>r</sub>]

**递归终止条件**：当前序区间长度等于0时结束（不存在二叉树）

**优化**：每次都需要在中序遍历中找到根节点的位置，可以**使用HashMap存储根节点位置，直接获取**


```java
public TreeNode buildTreeiml(int[] preorder,int[] inorder,int pl,int pr, int il,int ir){
    // 区间为0,构造结束
    if(pl > pr){
        return null;
    }
    // 前序遍历
    // 直接使用i保存
    int i = 0;
    for(i=il; i<=ir; i++){
        if(inorder[i] == preorder[pl]){
            break;
        }
    }
    // 左子树长度 i-1-il+1 = i-il
    int n = i-il;

    // 创建当前子树的根节点
    TreeNode root = new TreeNode(preorder[pl]);
    // 构造子树
    root.left = buildTreeiml(preorder,inorder,pl+1,pl+n,il,i-1);
    root.right = buildTreeiml(preorder,inorder,pl+n+1,pr,i+1,ir);
    return root;
}
```

## [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

**树的高度和深度**

- 深度定义是从上往下的
  - 前序遍历：根左右，从上往下，符合深度定义的

- 高度定义是从下往上的
  - 后序遍历：左右根，从下往上，符合高度定义的


```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        int l = maxDepth(root.left);
        int r = maxDepth(root.right);
        return Math.max(l,r) + 1;
    }
}
```

## [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

最小深度是从**根节点到最近叶子节点的最短路径上的节点数量**，当只有一棵子树为空时，那条路径不是叶子节点路径，不能不参与比较

```java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        int l = minDepth(root.left);
        int r = minDepth(root.right);
        // 非叶子节点不参与比较，有一个为0，加法统一处理
        if(root.left == null || root.right == null){
           return l + r + 1;
        }
        return Math.min(l,r) + 1;
    }
}
```

## [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

直径长度是任意两个结点路径长度中的最大值，直径可能穿过也可能不穿过根结点

所以并不一定就是根节点的子树深度和，有可能子节点的子树深度和更大，所以需要包含两部分

- 节点左右子树的深度，用于递归向上传递计算直径
- 每个节点的子树的最大直径和，需要用一个变量来存储比较

```java
// 后续遍历，在每个节点存下面的最大直径
class Solution {
    int ans = 0;
    // 笨比写法，直接传入root递归即可
    // public int diameterOfBinaryTree(TreeNode root) {
    //     int l = diameterOfBinaryTreeiml(root.left);
    //     int r = diameterOfBinaryTreeiml(root.right);
    //     if(l+r > ans){
    //         ans = l+r;
    //     }
    //     return ans;
    // }
    public int diameterOfBinaryTree(TreeNode root) {
        // 可以不用变量接收
        diameterOfBinaryTreeiml(root);
        return ans;
    }
    public int diameterOfBinaryTreeiml(TreeNode root) {
        if(root == null){
            return 0;
        }
        int l = diameterOfBinaryTreeiml(root.left);
        int r = diameterOfBinaryTreeiml(root.right);
        if(l+r > ans){
            ans = l+r;
        }
        return Math.max(l,r)+1;
    }
}
```

## [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

最大路径：同一个节点在一条路径序列中**至多出现一次**，该路径**至少包含一个**节点，且不一定经过根节点

- 路径和是节点值，而不是节点深度，因此比较的就是节点值
- 节点值存在负数

所以每次路径和有4种选择

1. 左右子节点值小于0，仅选择根节点
   1. 向上传递根节点值
2. 左子节点值小于0，选择根和右子节点
   1. 向上传递根节点值和右子节点值的和
3. 右子节点小于0，选择根和左子节点
   1. 向上传递根节点和左子节点的值的和
4. 左右子节点大于0，选择左右和根节点
   1. 向上传递根节点和左右子节点值较大的和

```java
```





## 二叉搜索树





## 平衡二叉树AVL



## B+树



## 红黑树



# 前缀树Trie

Trie（前缀树，字典树）是一种用于快速查询某个字符串/字符前缀是否存在的数据结构

- 特殊的多叉树
  - 孩子节点`next`是一个大小为26的一维数组（输入只有小写字符），分别对应了26个英文字符，即26叉树
  - `isWord`表示从根节点到当前节点为止，该路径是否形成了一个有效的字符串

```java
class TrieNode {
    TrieNode[] next = new TrieNode[26];
    // 该节点是否是一个字符串的结束
    boolean isWord;
}
```

## 构建前缀树

1. 根节点不保存任何信息
2. 字符串存放到前缀树时，需要把它拆成一个个字符
   1. 每个字符按照在字母表的顺序，放在children对应的位置，下一个字符是当前字符的所在节点的子节点
   2. 所有以相同字符开头的字符串，会聚合到同一个子树上
3. 字符串构建前缀树到最后一个字符时，需要把该节点的`isWord`标记为`true`，说明从根节点到当前节点的路径构成了一个字符串
   1. 所以并不一定是到达叶子节点才形成了一个字符串，只要节点的`isWord`为`true`，那么从根节点到当前节点的路径构成了一个字符串

```java
public void insert(String s) {
    TrieNode p = root;
    for(int i=0; i<s.length(); i++) {
        int t = s.charAt(i) - 'a';
        if(p.next[t] == null){
            p.next[t] == new TrieNode();
        }
        p = p.next[t]; 
    }
    p.isWord = true;
}
```

## 查询前缀树

判断一个字符串是否在前缀树中时，需要依次遍历字符串所有字符

在前缀树上遍历字符会有三种情况

1. 在前缀树上遍历的过程中，发现树中没有对应字符的节点
2. 在前缀树上遍历的过程中，找到了字符串对应字符的所有连续节点，但是最后一个字符对应的节点的`isWord`为`false`
3. 在前缀树上遍历的过程中，找到了字符串对应字符的所有连续节点，但是最后一个字符对应的节点的`isWord`为`true`

### TrieNode结构实现

```java
class Trie {
    
    class TrieNode{
        TrieNode[] next = new TrieNode[26];
        boolean isWord;
    }
    
    private TrieNode root;
    
    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode p = root;
        for(int i=0; i<word.length(); i++){
            int t = word.charAt(i)-'a';
            if(p.next[t] == null){
                p.next[t] = new TrieNode();
            }
            p = p.next[t];
        }
        p.isWord = true;
    }
    
    public boolean search(String word) {
        TrieNode p = root;
        for(int i=0; i<word.length(); i++){
            int t = word.charAt(i)-'a';
            if(p.next[t] == null){
                return false;
            }
            p = p.next[t];
        }
        return p.isWord;
    }
    
    public boolean startsWith(String prefix) {
        TrieNode p = root;
        for(int i=0; i<prefix.length(); i++){
            int t = prefix.charAt(i)-'a';
            if(p.next[t] == null){
                return false;
            }
            p = p.next[t];
        }
        return true;
    }
}
```

### 二维数组实现

1. 使用二维数组trie存储所有字符串
2. 使用index来记录用了多少个数组的位置
3. 使用一维数组count来记录某个位置被标记未结尾的次数

```java
class Trie {
    // N不好估算
    int N = 100009;
    int[][] trie;
    int[] count;
    int index;

    public Trie() {
        trie = new int[N][26];
        count = new int[N];
        index = 0;
    }
    
    public void insert(String s) {
        int p = 0;
        for (int i=0; i<s.length(); i++) {
            int t = s.charAt(i) - 'a';
            if (trie[p][t] == 0){
                trie[p][t] = index++;
            }
            p = trie[p][t];
        }
        count[p]++;
    }
    
    public boolean search(String s) {
        int p = 0;
        for (int i=0; i<s.length(); i++) {
            int t = s.charAt(i) - 'a';
            if (trie[p][t] == 0){
                return false;
            }
            p = trie[p][t];
        }
        return count[p] != 0;
    }
    
    public boolean startsWith(String s) {
        int p = 0;
        for (int i=0; i<s.length(); i++) {
            int t = s.charAt(i) - 'a';
            if (trie[p][t] == 0){
                return false;
            }
            p = trie[p][t];
        }
        return true;
    }
}
```

## Trie的应用场景

- 自动补全
- 拼写检查

在工程中，不考虑前缀匹配的话，基本上使用hash就能满足。如果考虑前缀匹配的话，工程也不会使用Trie

- 字符集大小不好确定，工程一般兼容各种字符集，一旦字符集大小很大的话，Trie将会带来很大的空间浪费
  - 做题只考虑26个字母，字符集大小限制在较小的26内，因此可以使用Trie

- 对于个别的超长字符，Trie会进一步变深
  - 如果Trie存储在硬盘中，Trie结构过深带来的影响是多次随机IO，随机IO是成本很高的操作

- 因为Trie的特殊结构，也会为分布式存储将会带来困难

> 至于一些诸如联想输入、模糊匹配、全文检索的典型场景在工程主要是通过ElasticSearch解决
>
> - 而ElasticSearch的实现则主要是依靠倒排索引



# 堆

## 最大堆

```java
public class MaxHeap {
    // 使用数组创建完全二叉树的结构，然后使用二叉树构建一个堆
    int[] maxHeap;
    // heapSize记录数组大小，创建数组时指明数组的元素个数
    int heapSize;
    // realSize记录堆的元素个数
    int realSize = 0;

    public MaxHeap(int heapSize) {
        this.heapSize = heapSize;
        // 为了便于完全二叉树的管理，不使用数组的第0个索引，随便设置一个值
        maxHeap = new int[heapSize+1];
        maxHeap[0] = 0;
    }

    // 添加元素
    public void add(int element) {
        realSize++;
        // 如果堆中元素的个数大于一开始设定的数组的个数，则返回异常
        if (realSize > heapSize) {
            System.out.println("Add too many elements!");
            realSize--;
            return;
        }
        // 将添加的元素添加到数组中
        maxHeap[realSize] = element;
        // 新增元素的索引位置
        int index = realSize;
        // 新增元素的父节点的索引位置
        // 注意，如果用数组表示完全二叉树，并且根结点存储在数组的索引1的位置的时候，任何一个节点的父节点索引位置为「该节点的索引位置/2」，任何一个节点的左孩子节点的索引位置为「该节点的索引位置*2」，任何一个节点的右孩子节点的索引位置为「该节点的索引位置*2+1」
        int parent = index / 2;
        // 当添加的元素大于父节点时，需要将父节点的值和新增元素的值交换
        while ( maxHeap[index] > maxHeap[parent] && index > 1 ) {
            int temp = maxHeap[index];
            maxHeap[index] = maxHeap[parent];
            maxHeap[parent] = temp;
            index = parent;
            parent = index / 2;
        }
    }

    // 获取堆顶元素函数
    public int peek() {
        return maxHeap[1];
    }

    // 删除堆顶元素函数
    public int pop() {
        // 如果当前「堆」的元素个数为0， 则返回「Don't have any element」
        if (realSize < 1) {
            System.out.println("Don't have any element!");
            return Integer.MIN_VALUE;
        } else {
            // 当前「堆」中含有元素
            // realSize >= 1
            int removeElement = maxHeap[1];
            // 将「堆」中的最后一个元素赋值给堆顶元素
            maxHeap[1] = maxHeap[realSize];
            realSize--;
            int index = 1;
            // 当删除的元素不是孩子节点时
            while (index < realSize && index <= realSize / 2) {
                // 被删除节点的左孩子节点
                int left = index * 2;
                // 被删除节点的右孩子节点
                int right = (index * 2) + 1;
                // 当删除节点的元素小于 左孩子节点或者右孩子节点，代表该元素的值小，此时需要将该元素与左、右孩子节点中最大的值进行交换
                if (maxHeap[index] < maxHeap[left] || maxHeap[index] < maxHeap[right]) {
                    if (maxHeap[left] > maxHeap[right]) {
                        int temp = maxHeap[left];
                        maxHeap[left] = maxHeap[index];
                        maxHeap[index] = temp;
                        index = left;
                    } else {
                        // maxHeap[left] <= maxHeap[right]
                        int temp = maxHeap[right];
                        maxHeap[right] = maxHeap[index];
                        maxHeap[index] = temp;
                        index = right;
                    }
                } else {
                    break;
                }
            }
            return removeElement;
        } 
    }

    // 返回「堆」的元素个数
    public int size() {
        return realSize;
    }

    public String toString() {
        if (realSize == 0) {
            return "No element!";
        } else {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            for (int i = 1; i <= realSize; i++) {
                sb.append(maxHeap[i]);
                sb.append(',');
            }
            sb.deleteCharAt(sb.length() - 1);
            sb.append(']');
            return sb.toString();
        }
    }
```





# BitOperation位运算

- `&`与：两个位都为1时，结果才为1
- `|`或：两个位都为0时，结果才为0
- `^`异或：两个位相同为0，相异为1
  - 将一个数置0，只要和自己异或即可
- `~`取反：0变1，1变0



## [剑指65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

### 迭代

int二进制表示有32位，占4个字节，右移最多32次就会变成0

```java
public int getSum(int a, int b) {
    
    int ans = 0;
    int t = 0;
    // a,b右移，t左移
    for (int i=0; i<32; i++) {
        int u1 = (a >> i) & 1;
        int u2 = (b >> i) & 1;
        if (u1 == 1 && u2 == 1) {
            ans |= (t << i);
            t = 1;
        } else if (u1 == 1 || u2 == 1) {
            ans |= ((1 ^ t) << i);
        } else {
            ans |= (t << i);
            t = 0;
        }

    }
    return ans;
}
```

### 递归

计算`a+b`

1. 不考虑进位的情况下的所有位的加和结果为`a^b`
2. 单独考虑加法的进位情况`carry = a&b`
   1. 当前进位carry都是应用于下一位的加和，所以要加的进位对齐为`carry >> 1`
3. 将没有进位的`a^b`和进位结果`a&b>>1`做加和运算，即递归

```java
public int getSum(int a, int b) {
    return b == 0 ? a : getSum(a^b, (a&b) << 1);
}
```



## [1470. 重新排列数组](https://leetcode-cn.com/problems/shuffle-the-array/)

**思路一**

- 数是二进制表示，**用数存数**


- 题目限制数据范围最大只能是1000，所以每一个元素最多只占据了10bit（2^10 - 1 = 1023 > 1000）
  - `int`类型占32bit，所以可以使用剩下的22bit做存储，本题只用10bit就够了
  - 数据的低10位（0-9） 存储原本的数据	
  - 往前10位（10-19 ）存储重新排列的数据
  - 取数据的前10位就是答案（右移10位）

`&`：二进制**取位**操作，0x3FF即1023（10进制），1111111111（2进制）

`|`：二进制特定位上的无条件赋值

```java
// 奇偶位
j = i < n ? i*2 : (i-n)*2+1;
// & 取二进制的低10位, | 赋值到前10位
nums[j] |= (nums[i] & 0x3FF) << 10;
nums[j] >> 10
```

**思路二**

题目限制数据范围都是正数，可以用负数做标记

1. 将nums[i]存到应该的位置nums[j]上，并标记为数据的相反数
2. 将nums[j]存到nums[i]上，并根据之前的j计算它应该在的位置，继续交换，标记为相反数
3. 直到所有数都标记为相反数（负数）
4. 转换回正数

## [1763. 最长的美好子字符串](https://leetcode-cn.com/problems/longest-nice-substring/)

利用一个数的二进制位来存一些**判断是否存在的信息**

> `int`类型就可以存32位，可以满足26位英文字母存储

```java
public String longestNiceSubstring(String s) {
    int l = 0;
    int ans = 0;
    int n = s.length();
    for(int i=0; i<n; i++){
        // 使用ab的后26位来存储每个字母
        int a = 0;
        int b = 0;
        for(int j=i; j<n; j++){
            char t = s.charAt(j);
            if(t >= 'a' && t <= 'z'){
                a |= (1 << (t - 'a'));
            }
            else{
                b |= (1 << (t - 'A'));
            }
            if(a == b && j-i+1 > l){
                l = j-i+1;
                ans = i;                    
            }
        }
    }
    if(l == 0){
        return "";
    }
    return s.substring(ans,ans+l);
}
```



# DynamicProgramming动态规划

问题的一般形式：**求最值**

- 如何穷举所有可能
- 存在大量重复计算
  - 时间复杂度爆炸

> 计算机解决问题没有任何特殊技巧，它唯一的解决办法就是穷举
>
> 算法设计无非是先思考如何穷举，再追求聪明的穷举（穷举+剪枝）

**DP三要素**

- 重叠子问题
- 最优子结构
  - 由子问题的最优结果推导出更大问题的最优结果
  - 要求子问题之间互相独立
- 状态转移方程

**思考问题**

1. **base case**：最简单情况
   1. `dp[0]`，`dp[0][0]`
2. 问题有哪些**状态**
   1. 问题和子问题的**变量**
3. 状态转移
   1. 对于每个**状态**，可以做出哪些**选择**使状态改变（改变变量）
4. 定义`dp`数组表现选择和状态

**自底向上**

- DP是自底向上，由base case迭代出问题答案

> 递归是自顶向下，由问题答案递归找结果，递归的时间复杂度是指数级

## 遍历方向



## 状态压缩

优化dp数组

## 背包

### 0-1背包

- 背包容量c
- n个物品：体积vi，价格pi

#### 暴力枚举

**时间复杂度**：`o(2^n)`

对于物品ni有两种选择

- 选：`knapsack(i-1,c-vi)+pi`
- 不选：`knapsack(i-1,c)`

`knapsack(i,c) = max{knapsack(i-1,c-vi)+pi,knapsack(i-1,c)}`

#### 备忘录

使用`P[i,c]`记录前i个物品，容量为c的最优解

- `P[0,c] = P[i,0] = 0`

`P[i,c] = max{P[i-1,c-vi]+pi,P[i-1,c]}`

> 将选或不选的子问题的结果记录下来，后续直接使用，不用再递归

#### 最优解追踪

倒序判断是否选择物品ni

`Rec[i,c]`：选为1，不选为0

### 多重背包

### 完全背包

## [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

LIS：Longest Increasing Subsequence

- 子序列不要求连续

**时间复杂度**：`o(n^2)`

> 二分搜索：`o(nlogn)`

1. 状态数组
   1. `dp[i]`：以`nums[i]`结尾的子序列的最长递增子序列的长度
2. base case
   1. `dp[i] = 1`：初始只有自身
3. 状态转移
   1. 由`dp[0]`~`dp[i-1]`推出`dp[i]`
   2. 对于`dp[i]`
      1. 需要判断`nums[i]`是否符合递增条件
      2. 可能构成多个递增子序列，找出最大值

> 即对`nums[0]`~`nums[i-1]`判断是否构成递增子序列



### 二分

**时间复杂度**：`o(nlogn)`

> 耐心排序

**贪心**

在遍历过程中使用维护`f`使得子序列的结尾元素最小

- 当每次向LIS末尾添加的元素是剩余元素中**尽可能小的元素时**，LIS的增长速率就相对更低
- 假设LIS的末尾添加了元素A（A > B），那么后续向LIS添加的元素一定大于A，即也会大于B，此时相当于B被遗漏了，LIS不是最长的，所以要添加尽可能小的元素

**思想**

- 传统动态规划的方法由遍历dp数组和计算`dp[i]`组成，其中计算`dp[i]`的时间复杂度是`o(n)`，考虑将dp数组改造为有序的列表，这样在计算`dp[i]`时候，可以通过二分的方式遍历`[0,k-1]`区间的元素，复杂度降低为`o(logn)`


- 在遍历数组`nums`的同时，维护一个具有**单调性的数组**`f`，`f[l]=x`表示长度为`l+1`的子序列的**最小结尾元素**是`x`

**步骤**

1. 如果当前元素`nums[i]`大于`f`中的所有的数`f[i]`
   1. 表示`nums[i]`可以接在前面所有长度的子序列后，将其添加到`f`末尾作为`f[i+1]`，表示长度+1

2. 如果当前元素`nums[i]`小于`f`中的某一个数`f[i]`
   1. 通过二分查找到比`nums[i]`大的最小的`f[i]`，表示将`nums[i]`作为此`f[i]`后面可能接更长的序列，即`f[i] = nums[i]`

3. 如果当前元素`nums[i]`等于`f`中的某一个数`f[i]`
   1. 说明已经存在，跳过


> 因为根据f数组的定义，`f[l]=x`表示长度为`l+1`的子序列的**最小结尾元素**是`x`，所以在二分查找的过程中，找到第一个比`nums[i]`大的`f[i]`就可以直接替换，因为`f[i-1]`就可以作为`f[i]`表示的序列的前一个数（长度差1，就是差最后一个元素`f[i]`），而二分查找保证了`nums[i]`是大于`f[i-1]`的，所以用`nums[i]`替换掉`f[i]`，仍然可以构成长度为`i+1`的上升子序列

**状态压缩**

- 本质是维护各个长的的子序列数组，但实际只用到每个子序列的最后一个元素，所以状态压缩为一维的`f`

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if (len <= 1) {
            return len;
        }
        // f:长度为i+1的上升子序列的末尾最小是x
        int[] f = new int[len];
        // base case:nums[0]直接作为f的首元素
        f[0] = nums[0];
        // 记录f的最后一个已经赋值元素的索引
        int end = 0;
        for(int i=1; i<len; i++){
            // 比所有数都大直接加在末尾
            if (nums[i] > f[end]) {
                end++;
                f[end] = nums[i];
            } 
            else{
                // 二分查找第1个大于等于nums[i]的元素,替换
                int l = 0;
                int r = end;
                while(l < r){
                    int mid = l + (r - l) / 2;
                    if (f[mid] < nums[i]){
                        l = mid + 1;
                    }
                    else{
                        r = mid;
                    }
                }
				// 一定存在比nums[i]大的元素,直接复制
                f[l] = nums[i];
            }
        }
		// 长度即为i+1
        return end+1;
    }
}
```



## [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

在LIS中再增加一个路径信息数组



## 最大子数组和

**连续的问题应该以`nums[i]`结尾**

**时间复杂度**：`o(n)`

空间复杂度：`o(1)`

> 子序列不连续，子数组连续
>
> 买卖股票问题

1. 状态数组
   1. `dp[i]`：以`nums[i]`结尾的子数组的和
2. base case
   1. `dp[i] = nums[i]`：初始只有自身
3. 状态转移
   1. 由于子数组要求连续，只能由`dp[i-1]`来推出`dp[i]`
      1. 当`dp[i-1] > 0`，直接加上即可，`dp[i] = dp[i-1]+nums[i]`
      2. 当`dp[i-1] < 0`，`dp[i] = nums[i]`

> 一开始考虑`nums[i]`和0，后来发现应该是`dp[i-1]`和0
>
> 因为dp数组是以`nums[i]`结尾，所以必须包含，那么要考虑的是是否包含`dp[i-1]`

### 分治

时间复杂度：`o(nlogn)`

空间复杂度：`o(logn)`

**问题求解**

- 对于区间`[l,r]`，取`mid = l + (r-l)/2`，对`[l,mid]`和`[mid+1,r]`分治，递归深入，直到区间长度为1时（区间`[n,n]`）返回
- 递归过程中维护区间的4个变量
  - `ls`：`[l,r]`区间以`l`为左端点的最大子数组和
  - `rs`：`[l,r]`区间以`r`为右端点的最大子数组和
  - `ms`：`[l,r]`区间内的最大子数组和
  - `is`：`[l,r]`区间所有数的和

**递归过程**

考虑如何合并`[l,mid]`和`[mid+1,r]`得到`[l,r]`区间信息

- 对于长度为1的区间`[n,n]`，4个变量值都等于`nums[n]`

- 对于长度大于1的区间

  - `[l,r]`的区间和`is`：`[l,mid]`的`is`和`[mid+1,r]`的`is`的和
  - `[l,r]`的区间和`ls`：取二者的较大值
    - `[l,mid]`的的`ls`
    - `[l,mid]`的`is`和`[mid+1,r]`的`ls`的和
  - `[l,r]`的区间和`rs`：取二者的较大值
    - `[mid+1,r]`的的`rs`
    - `[l,mid]`的`rs`和`[mid+1,r]`的`is`的和

- 对于`[l,r]`区间内的最大子数组和`ms`，需要考虑最大子数组是否跨越`[l,mid]`和`[mid+1,r]`两个子区间

  - 不跨越：`[l,r]`的`ms`取`[l,mid]`的`ms`和`[mid+1,r]`的`ms`的较大值
  - 跨越：`[l,r]`的`ms`取`[l,mid]`的`rs`和`[mid+1,r]`的`ls`的和

  求出三个值的最大值，即为`[l,r]`的`ms`

```java
class Solution {
    // 定义一个类，包含递归过程中的4个状态量
    public class Status {
        public int lSum, rSum, mSum, iSum;
        // 构造器
        public Status(int lSum, int rSum, int mSum, int iSum) {
            this.lSum = lSum;
            this.rSum = rSum;
            this.mSum = mSum;
            this.iSum = iSum;
        }
    }

    public int maxSubArray(int[] nums) {
        // 获取Status类型对象的mSum属性值
        return getmax(nums, 0, nums.length - 1).mSum;
    }

    // 返回Status类型对象
    public Status getmax(int[] nums, int l, int r) {
        // 区间为1,返回
        if (l == r) {
            // 所有值都是nums[l]
            return new Status(nums[l], nums[l], nums[l], nums[l]);
        }
        int m = (l + r) >> 1;
        // 递归
        Status lSub = getmax(nums, l, m);
        Status rSub = getmax(nums, m + 1, r);
        // 合并
        return pushUp(lSub, rSub);
    }

    // 合并区间,返回Status类型对象
    public Status pushUp(Status l, Status r) {
        int iSum = l.iSum + r.iSum;
        int lSum = Math.max(l.lSum, l.iSum + r.lSum);
        int rSum = Math.max(r.rSum, r.iSum + l.rSum);
        int mSum = Math.max(Math.max(l.mSum, r.mSum), l.rSum + r.lSum);
        return new Status(lSum, rSum, mSum, iSum);
    }
}
```





## 最长公共子序列



## 最长公共子串



## [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

只能向右或向下走，即当前单元格`(i,j)`只能从左方单元格`(i−1,j)`或上方单元格`(i,j−1)`走到，**只需要考虑矩阵左边界和上边界**

> 典型的动态规划题目，暴搜会超时
>

```java
public int minPathSum(int[][] grid) {
    int m = grid.length;
    int n = grid[m-1].length;
    int[][] dp = new int[m][n];
    // 只能向下或向右
    dp[0][0] = grid[0][0];
    for(int i=1; i<m; i++){
        dp[i][0] = grid[i][0] + dp[i-1][0]; 
    }
    for(int j=1; j<n; j++){
        dp[0][j] += grid[0][j] + dp[0][j-1];
    }
    for(int i=1; i<m; i++){
        for(int j=1; j<n; j++){
            dp[i][j] = grid[i][j] + Math.min(dp[i-1][j],dp[i][j-1]);
        }
    }
    return dp[m-1][n-1];
}
```

### 状态压缩

> 不需要建立dp数组浪费额外空间，直接遍历原数组原地修改即可

将二维数组`dp[m][n]`优化成一维数组`dp[n]`

1. 因为`dp[i][j]`只和`dp[i-1][j]`和`dp[i][j-1]`有关，即只和前一行的数组值有关，和再之前的行值无关，所以只需要使用`dp[n]`存储`i-1`行的数据即可
2. `dp[n]`的值**依次代表每一行的值，然后被更新**
   1. `dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]`对应到一维，可以知道当计算`dp[j]`时，`dp[j]`是未更新的值，即`dp[j] = dp[i-1][j]`，而`dp[j-1]`在上一轮已经更新完成，所以`dp[j-1] = dp[i][j-1]`
   2.  所以一维的状态转移方程为`dp[j] = Math.min(dp[j-1],dp[j]) + grid[i][j]`

```java
public int minPathSum(int[][] grid) {
    int m = grid.length;
    int n = grid[m-1].length;
    int[] dp = new int[n];
    // 只能向下或向右
    dp[0] = 0;
    for(int i=0; i<m; i++){
        for(int j=0; j<n; j++){
            if(j == 0){
                dp[j] += grid[i][j];
            }
            else if(i == 0){
                dp[j] = dp[j-1] + grid[0][j];
            }
            else{
                // i != 0 && j != 0
                dp[j] = Math.min(dp[j-1],dp[j]) + grid[i][j];
            }
        }
    }
    return dp[n-1];
}
```

## [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

> 解决两个字符串的DP问题，一般都是用双指针从两个字符串的末尾出发，缩小问题规模

1. 状态数组
   1. 问题的变量：用双指针`i`，`j`从两个字符串的末尾遍历，所以状态就是指针`i`，`j`的**位置信息**
   2. `dp[i][j]`：将`word1[0~i]`转换到`word2[0~j]`所使用的最少操作次数
2. base case
   1. `dp[i][0]`，`dp[0][j]`
   1. 当有一个字符串的长度为0时，转化为另外一个字符串就只能**一直进行插入或者删除操作**
3. 状态转移
   1. 每次有4种选择
      1. 如果当前两个字符相等，则**跳过**
      2. 如果当前两个字符不相等，则可以**插入**，**删除**，**替换**
   2. 在需要操作的三种选择中选择最小的次数

**问题**



```java
```









# BackTracking回溯和搜索

一种**选优搜索算法**，又称为**试探法**

- 按选优条件向前**搜索**以达到目标
- 当探索到某一步时，发现原先选择并不优或达不到目标，就**退回一步重新选择**

> 满足回溯条件的某个状态的点称为**回溯点**

## 决策树的遍历

可以看成是递归调用的一种特殊形式，递归调用前需要做出选择，递归返回后需要撤销选择

1. **路径**：做出的选择
2. **选择列表**：当前可选择的选项
3. **结束条件**：决策树底层，无法再做选择

```python
result = []
# 回溯算法中函数返回值⼀般为void
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        # 过滤减枝
        
        # 前序遍历
        做选择，修改选择列表
        backtrack(路径, 选择列表)
        # 后序遍历
        撤销选择，修改选择列表
```

## 回溯决策树

决策树上每个节点都有2个属性

- 路径
- 选择

在遍历时维护每一个节点的属性

> 节点的不同属性称为状态



## 前序遍历和后序遍历

- 前序遍历：进入某个节点之前的时间点执行
  - **做选择**
- 后序遍历：离开某个节点之后的时间点执行
  - **撤销选择**



## 全排列

`backtrack(first,output)`表示从左往右填到第`first`个位置，当前排列为`output`

1. `first = n`
   1. 找到一个解，添加答案
2. `first < n`
   1. 找到一个没填过的数字
      1. 标记数组`vis`
   2. 填下一个位置`backtrack(first+1,output)`
   3. 回溯时，撤销这一步找的数字，重置标记数组`vis`
   4. 找到另一个没填过的数字...

> `Map.put(nums[i],1)`

**优化**：去掉标记数组

将nums划分成两部分

- 已经用过的数：`[0,first-1]`
- 未用过的数：`[first,n-1]`

使用`[first,n-1]`中的一个数`nums[i]`填入，然后交换`first`和`nums[i]`



## 广度优先搜索BFS

BFS可以看成是层序遍历，就像蜻蜓点水一样从起点往外扩散，每次遍历一圈上的节点（和当前点相邻的节点），**将节点加入队列**。一圈上的节点距离都是1，所以只要是这个圈上的节点，距离就+1

- **BFS找到的路径一定是最短的**
- 时间复杂度：最坏情况是`o(n)`
- 空间复杂度较高

> 如果一个问题是关于事物状态的改变，那么可以考虑把该问题转化为图的搜索问题。每一个状态对应图中的一个节点，若两个状态之间可以相互转化，则两个节点之间存在一条边
>

```java
// 普通的二维坐标可以用数组来存储
// Queue<int[]> q = new LinkedList<>();
// q.add(new int[]{row,col});
// 取出0，1索引即可
// int[] t = q.poll();
// int x = tmp[0];
// int y = tmp[1];

public int BFS(Node start,Node target){
    Queue<Node> q;
    Set<Node> vis;
    
    q.offer(start);
    vis.add(start);
    int step = 0;
    while(!q.isEmpty()){
        // 区分每一层
        int size = q.size();
        for(int i=0; i<size; i++){
            Node cur = q.poll();
            if(cur == target){
                return step;
            }
            // cur.adj()指和cur相邻的可达的节点
            for(Node t : cur.adj()){
                if(!vis.contains(t)){
                    q.offer(t);
                    vis.add(t);
                }
            }
        }
        // 每一层是一步
        step++;
    }
}
```

`cur.adj()`

```java
// 方向数组,上下左右
int[][] dir = new int[][]{{-1,0},{0,1},{1,0},{0,-1}};

// 方向数组,上下左右和斜线
int[][] dir = new int[][]{{-1,0},{0,1},{1,0},{0,-1},{-1,1},{1,1},{1,-1},{-1,-1}};

// 遍历周围节点
for(int i=0; i<dir.length; i++){
    Node t1 = q.poll();
    Node t2 = new Node;
    t2.x = t1.x + dir[i][0];
    t2.y = t1.y + dir[i][1];
    if(vis.contains(t2)){
        continue;
    }
    q.offer(t2)
}
```



## 双向BFS

从起点和终点同时遍历，维护各自的集合，当集合存在交集时，即找到最短路径

- 轮流扩散q1,q2

```java
public int doubleBFS(Node start,Node target){
    Set<Node> q1;
    Set<Node> q2;
    Set<Node> vis;
    q1.add(start);
    q2.add(end)
    int step = 0;
    while(!q1.isEmpty() && !q2.isEmpty()){
        // 存储q1扩散的结果，用于交换
        Set<Node> tmp;
        for(Node cur : q1){
            // q1，q2存在交集，target可达，返回step
            if(q2.contains(cur)){
                return step;
            }
            vis.add(cur);
            for(Node t : cur.adj()){
                if(!vis.contains(t)){
                    tmp.add(t);
                    vis.add(t);
                }
            }
        }
        step++;
        // 交换q1,q2，下一轮扩展q2
        q1 = q2;
        q2 = tmp;
    }
}
```

## 多源BFS

### [1765. 地图中的最高点](https://leetcode-cn.com/problems/map-of-highest-peak/)

## 记忆化搜索

就是在搜索过程中会走到重复的节点

### [688. 骑士在棋盘上的概率](https://leetcode-cn.com/problems/knight-probability-in-chessboard/)

当k比较大时，棋盘上的同一个位置在剩余x次时有可能会重复的到达，所以需要加一个缓存，也就是记忆化搜索

```java
int[][] dirs = new int[][]{{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1}};
public double knightProbability(int n, int k, int row, int column) {
    double[][][] memo = new double[n][n][k+1];
    return dfs(n,row,column,k,memo);
}
public double dfs(int n, int i, int j, int k,double[][][] memo){
    // 出界，当前路径没有成功概率
    if(i<0 || i>=n || j<0 || j>=n){
        return 0;
    }
    // 未出界
    if(k == 0){
        return 1;
    }
    if(memo[i][j][k] != 0){
        return memo[i][j][k];
    }
    double ans = 0;
    for(int[] dir : dirs){
        int x = i + dir[0];
        int y = j + dir[1];
        ans += dfs(n,x,y,k-1,memo)/8;
    }
    memo[i][j][k] = ans;
    return ans;
}
```



## 岛屿问题

> 岛屿问题是网格结构DFS问题的典型代表

遍历模板

```java
public void dfs(int[][] grid, int i, int j, boolean[] visited) {
    int m = grid.length;
    int n = grid[0].length;
    // 超出索引边界
    if (i < 0 || j < 0 || i >= m || j >= n) {
        // 更新值
        return;
    }
    // 已遍历过
    if (visited[i][j]) {
     	// 更新值
        return;
    }
    // 前序：进入邻接节点（上下左右）
    visited[i][j] = true;
    dfs(grid, i-1, j); 
    dfs(grid, i+1, j); 
    dfs(grid, i, j-1); 
    dfs(grid, i, j+1);  
    // 后序：离开当前节点
  	// 回溯就需要还原
    // visited[i][j] = true;
}
```

使用**方向数组**遍历邻接节点

```java
// 方向数组
// {-1,0}：上
// {1,0}：下
// {0,-1}：左
// {0,1}：右
int[][] dirs = new int[][]{{-1,0}, {1,0}, {0,-1}, {0,1}};   
// 使用方向数组遍历邻接节点
for (int[] dir : dirs) {
    int in = i + dir[0];
    int jn = j + dir[1];
    dfs(grid, in, jn);
}
```



### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

### [1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/)

```java
class Solution {
    int[][] dirs = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};
    int val;
    public int closedIsland(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int ans = 0;
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(grid[i][j] == 0){
                    val = 1;
                    dfs(grid,i,j);
                    ans += val;
                }
            }
        }
        return ans;
    }
    public void dfs(int[][] grid, int i, int j){
        int m = grid.length;
        int n = grid[0].length;
        if(i<0 || i>=m || j<0 || j>=n){
            val = 0;
            return ;
        }
        if(grid[i][j] == 1){
            return ;
        }
        grid[i][j] = 1;
        for(int[] dir : dirs){
            int in = i + dir[0];
            int jn = j + dir[1];
            dfs(grid,in,jn);
        }
    }
}

// 先将边界的岛屿转换为海
// class Solution {
//     int[][] dirs = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};
//     public int closedIsland(int[][] grid) {
//         int m = grid.length;
//         int n = grid[0].length;
//         
//         for(int i=0; i<m; i++){
//             if(grid[i][0] == 0){
//                 dfs(grid,i,0);
//             }
//             if(grid[i][n-1] == 0){
//                 dfs(grid,i,n-1);
//             }
//         }
//         for(int j=0; j<n; j++){
//             if(grid[0][j] == 0){
//                 dfs(grid,0,j);
//             }
//             if(grid[m-1][j] == 0){
//                 dfs(grid,m-1,j);
//             }
//         }
//         int ans = 0;
//         for(int i=0; i<m; i++){
//             for(int j=0; j<n; j++){
//                 if(grid[i][j] == 0){
//                     dfs(grid,i,j);
//                     ans++;
//                 }
//             }
//         }
//         return ans;
//     }
//     public void dfs(int[][] grid, int i, int j){
//         int m = grid.length;
//         int n = grid[0].length;
//         if(i<0 || i>=m || j<0 || j>=n){
//             return ;
//         }
//         if(grid[i][j] == 1){
//             return ;
//         }
//         grid[i][j] = 1;
//         for(int[] dir : dirs){
//             int in = i + dir[0];
//             int jn = j + dir[1];
//             dfs(grid,in,jn);
//         }
//     }
// }
```

### [1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/)

```java
int[][] dirs = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};
int val;
boolean vaild;
public int numEnclaves(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    int ans = 0;
    for(int i=0; i<m; i++){
        for(int j=0; j<n; j++){
            if(grid[i][j] == 1){
                val = 0;
                vaild = true;
                dfs(grid,i,j);
                if(vaild){
                    ans += val;
                }
            }
        }
    }
    return ans;
}
public void dfs(int[][] grid, int i, int j){
    int m = grid.length;
    int n = grid[0].length;
    if(i<0 || i>=m || j<0 || j>=n){
        vaild = false;
        return ;
    }
    if(grid[i][j] == 0){
        return ;
    }
    val++;
    grid[i][j] = 0;
    for(int[] dir : dirs){
        int in = i + dir[0];
        int jn = j + dir[1];
        dfs(grid,in,jn);
    }
}
```

### [剑指II 105. 岛屿的最大面积](https://leetcode-cn.com/problems/ZL6zAn/)

常规做法：用一个**全局变量**统计每一个岛屿的面积

```java
int sum;
public int maxAreaOfIsland(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    int ans = 0;
    for(int i=0; i<m; i++){
        for(int j=0; j<n; j++){
            if(grid[i][j] == 1){
                sum = 0;
                dfs(grid,i,j);
                if(sum > ans){
                    ans = sum;
                }
            }
        }
    }
    return ans;
}
public void dfs(int[][] grid, int i, int j){
    int m = grid.length;
    int n = grid[0].length;
    if(i<0 || i>=m || j<0 || j>=n || grid[i][j] == 0){
        return;
    }
    sum++;
    grid[i][j] = 0;
    dfs(grid,i-1,j);
    dfs(grid,i+1,j);
    dfs(grid,i,j-1);
    dfs(grid,i,j+1);
}
```

从图的一个节点出发，遍历邻接节点其实跟二叉树的遍历一样

```java
public int maxAreaOfIsland(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    int ans = 0;
    for(int i=0; i<m; i++){
        for(int j=0; j<n; j++){
            if(grid[i][j] == 1){
                int t = dfs(grid,i,j);
                if(t > ans){
                    ans = t;
                }
            }
        }
    }
    return ans;
}
public int dfs(int[][] grid, int i, int j){
    int m = grid.length;
    int n = grid[0].length;
    if(i<0 || i>=m || j<0 || j>=n || grid[i][j] == 0){
        return 0;
    }
    grid[i][j] = 0;
    int t1 = dfs(grid,i-1,j);
    int t2 = dfs(grid,i+1,j);
    int t3 = dfs(grid,i,j-1);
    int t4 = dfs(grid,i,j+1);
    return t1+t2+t3+t4+1;
}
```



# SlidingWindow滑动窗口

- `[left,right)`称为一个窗口
  - 左闭右开，初始不含字符
- `need`和`window`相当于字符的计数器
- **窗口的左右边界一定是只往右边移动**
  - 先移动`right`找到满足的解
  - 再移动`left`优化满足的解

```java
public void slidingWindow(String s,String t){
    // need是目标字符串的字符数
    Map<Character,Integer> need;
    // window是窗口内的字符数
    Map<Character,Integer> window;
    char[] tch = t.toCharArray();
    char[] sch = s.toCharArray();
    for(char c : tch){
        need.put(c,need.getOrDefault(c,0)+1);
    }
    int left = 0;
    int right = 0;
    // 用于判断是否满足条件，即找到可行解
    int vaild = 0;
    while(right < s.size()){
        // c是将移入窗口的字符
        char c = sch[right];
        // 右移窗口右边界，因为是[)区间
        right++;
        
        // 处理窗口内数据
        
        // 判断左侧窗口是否需要收缩
        // 根据条件选择while or if
        while(window need shrink){
            // d是将移出窗口的字符
            char d = sch[left];
            // 右移窗口左边界
            left++;
            
            // 处理窗口内数据
        }
    }
}
```

## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```java
public int lengthOfLongestSubstring(String s) {
    int l = 0;
    int r = 0;
    // Map<Character,Integer> map = new HashMap<>();
    int[] hash = new int[255];
    int ans = 0;
    while(r < s.length()){
        char t = s.charAt(r);
        hash[t]++;
        r++;
        // 有重复时开始移动左边界，直到没有重复
        while(hash[t] > 1){
            char temp = s.charAt(l);
            hash[temp]--;
            l++;
        }
        // [)区间，不用+1
        if(r-l > ans){
            ans = r-l;
        }
    }
    return ans;
}
```







# UnionFind并查集

并查集主要用于解决一些**元素分组**的问题，它管理一系列**不相交的集合**

并查集有两种操作

- **合并**（Union）：把两个不相交的集合合并为一个集合
- **查询**（Find）：查询两个元素是否在同一个集合中

> 思想：用集合中的一个元素代表集合，即集合对应树的根节点

**应用**：解决图的**动态连通性**问题

- 使用森林来表示图的动态连通性

- 设定森林中的每棵树的**每个节点有一个指针指向其父节点**，如果是根节点则指针指向自己
- 用数组实现森林

> 判断图有几个连通分支，将连通分支连起来，图就是连通的

## 初始化

- 一开始互不连通，父节点指针都指向自己
- **时间复杂度**：`o(n)`

```java
// father数组用来存储每个元素的父节点
int father[N];
public void init(int n){
    // 一开始互不连通，父节点指针初始指向自己
    for(int i=1; i<=n; i++){
        father[i] = i;
    }     
}
```

## 查询

`find`：从某个节点向上遍历到根节点

- 时间复杂度：`o(n)`
- 即最差时树的高度，只有平衡二叉树的高度是`logn`

```java
public int find(int x){
    // 找到集合的代表元素根节点，返回
    if(father[x] == x){
        return x;
    }
    else{
        // 递归向上查找根节点
        return find(father[x]);
    }
}

// 简易写法
public int find(int x){
    return father[x] == x ? x : find(father[x]);
}
```

## 合并

`union`

- 时间复杂度：`o(1)`
- 靠左原则：将靠左边的元素作为父节点

```java
public void union(int i, int j) {
    int fi = find(i);
    int fj = find(j);
    if(fi != fj){
        father[fj] = fi;
    }
}
```

## 路径压缩

- 让每个元素到对应根节点的距离尽可能短，即**每个元素直接和所在集合的根节点相连**
- 在查询时将**沿途的每个节点的父节点都设为根节点**
- `find`函数的**时间复杂度**降低为`o(1)`

```java
public int find(int x){
    if(father[x] == x){
        return x;
    }
    else{
        // 递归向上查找根节点，设为父节点
        father[x] == find(father[x]);
        return father[x];
    }
}

// 赋值运算符=的优先级没有三元运算符?:高，这里要加括号
public int find(int x){
    return father[x] == x ? x : (father[x] = find(father[x]));
}
```

## 按秩合并

路径压缩只在查询时进行，并且只压缩一条路径。所以如果随意的合并，并查集最终的结构依旧可能比较复杂

- 应该把简单的树往复杂的树上合并，这样合并**到根节点距离变长的节点个数比较少**
- **当两棵树深度相同时，合并后树的深度会+1**

**树的平衡性优化**

- 使用`rank[]`数组**记录每个节点对应的树的深度**
- 初始化时所有节点的`rank`（秩）为1
- 合并时比较两个根节点的`rank`（秩），将rank较小节点的往较大的节点上合并
- 如果两个节点的rank相同，则`rank++`

> 每一次`find`都是对树的一次重构，会把叶节点以及其所有的祖先全部变成根节点的子节点，这也是为什么说rank会失真

```java
// father数组用来存储每个元素的父节点
// rank数组用来存储每个元素的秩
int father[N];
public void init(int n){
    // 一开始互不连通，父节点指针初始指向自己
    for(int i=1; i<=n; i++){
        father[i] = i;
        rank[i] = 1;
    }     
}


public void union(int i, int j) {
    int fi = find(i);
    int fj = find(j);
    if(fi != fj){
        // f1所在树更小
        if(rank[fi] <= rank[fj]){
            father[fi] = father[fj];
        }
        else{
            father[fj] = father[fi];
        }
        if(rank[fi] == rank[fj]){
            rank[fj]++;
        }
    }
}
```

**合并**

```java
int father[N];
public void init(int n){
    for(int i=1; i<=n; i++){
        father[i] = i;
    }     
}

public int find(int x){
    return father[x] == x ? x : (father[x] = find(father[x]));
}

public void union(int i, int j) {
    int fi = find(i);
    int fj = find(j);
    if(fi != fj){
        father[fj] = fi;
    }
}
```



# LRU



# LFU



# 图

图**节点的逻辑结构**和N叉树一样

```java
class Vertex{
    int id;
    Vertex[] neighbors;
}
```

## 图的存储

**点-边-点**

> 邻接矩阵判断某一个点的边情况时必须把所有点都遍历一遍才能知道两者之间有没有边，而邻接表只存和这个点连着的点，没有任何冗余计算

### 邻接矩阵

**Adjacency Matrix**

使用**二维矩阵**来存图，适用于存储边数较多的**稠密图**，当边数量m接近点的数量n的平方时，可定义为**稠密图**

> 无向图的邻接矩阵是一个对称矩阵

```java
// 无权图的邻接矩阵
boolean[][] matrix = new boolean[N][N];
// 带权图的邻接矩阵
int[][] weight = new int[N][N];

// 有向图的加边操作
void add(int a,int b,int c){
    // 代表从节点a指向节点b的一条边
    matrix[a][b] = true;
    
    // 代表从节点a到节点b有一条权重为c的边
    weight[a][b] = c;
}

// 无向图的加边操作
void add(int a,int b,int c){
    // 对称矩阵
    matrix[a][b] = true;
    matrix[b][a] = true;
    
    weight[a][b] = c;
    weight[b][a] = c;
}
```

### 邻接表

**Adjacency List**

使用链表来存图，适用于存储边数较少的**稀疏图**，当边数量m接近点的数量n时，可定义为**稀疏图**

- **邻接矩阵的冗余信息很多，对于稀疏图存储效率极低**
- 邻接表**无法快速判断两个节点是否相邻**

```java
// 有向无权图
// 每个List存储图中一个节点的所有邻居节点
List<List<Integer>> graph;

// 或者是List数组
List<Integer>[] graph;
```



### 链式前向星

用链式前向星这个数据结构来存图，适用于存储边数较少的**稀疏图**

> 链式前向星，一个特殊的数据结构
>
> 与数组存储单链表的实现一致（头插法）

```java
// 对每条边进行编号
int index;

// 存储某一个节点(a)所对应的边的集合（对应链表）的头结点(index)
int[] head = new int[N];

// 存储某一条边(idx)指向的节点
int end = new int[M];

// 用于找到某一条边(index)的下一条边（以链表的形式存储边）
int next = new int[M];

// 记录某条边的权重为多少
int weight = new int[M];

void add(int a,int b,int c) {
    // 当前边由a指向b，存储b
    end[index] = b;
    // head[a]记录的是a节点对应的所有边的链表头节点
    // 使用头插法将当前边存在上一条边的前面，即当前边的下一条边是之前的边链表的头节点
    next[index] = head[a];
    // 将当前边作为a节点对应所有边的链表的头节点
    head[a] = index;
    // 当前边的权重是c，w[a][b] = c
    weight[index] = c;
    // 边的编号自增
    index++;
}
```

# 数论

## GCD最大公约数

求最大公约数的主要方式有两种

- 更相减损法
- 欧几里得算法

### 欧几里得算法

**时间复杂度**：`o(log(a+b))`

```java
int gcd(int a, int b) { 
    return b == 0 ? a : gcd(b, a % b);
}
```



## 快速幂

时间复杂度：`o(logn)`

### 整数快速幂

#### 二分思想

$x^n = (x^{n/2})^2$

- 当n为偶数：$x^n = (x^{n/2})^2$
- 当n为奇数：$x^n = x*(x^{n/2})^2$

```java
// 递归快速幂
int fastpower(int a, int n)
{
    if (n == 0)
        return 1;
    if (n % 2 == 1)
        return fastpower(a, n-1) * a;
    // 记录temp,否则会计算两次n/2
    int temp = fastpower(a, n/2);
    return temp * temp;
}
```

#### 二进制思想


对于一个十进制数n，设n的二进制的表示为：$b_mb_{m-1}...b_2b_1$（$b_i$为二进制位上的值，$i∈[1,m]$）

即：$n = 2^{m-1}*b_m + 2^{m-2}*b_{m-1}+...+2^1*b_2+2^0*b_1$

所以有：$x^n = x^{2^{m-1}*b_m + 2^{m-2}*b_{m-1}+...+2^1*b_2+2^0*b_1}$

即：$x^n = x^{2^{m-1}*b_m}*x^{2^{m-2}*b_{m-1}}*...*x^{2^1*b_2}*x^{2^0*b_1}$

所以求$x^n$

1. 因为$b_i$的取值只有0或者1
   1. 当$b_i = 0$时，$x^{2^{i-1}*b_i} = x^0 = 1$
   2. 当$b_i = 1$时，$x^{2^{i-1}*b_i} = x^{2^{i-1}}$，即求出$x^1，x^2，x^4，x^8 ... x^{2^{m-1}}$
2. 获取n对应的二进制的各位值$b_i$
   1. n&1：判断二进制最右一位（最低位）的值
   2. n>>1：右移1位，继续判断

> $x^{-n} = {1/x}^n$

```java
// long or double
public double fastPower(double x, int n) {
    if(x == 0){
        return 0;
    }
    // int32变量n∈[-2147483648,2147483647]
    // 当n=-2147483648时，n = -n会越界出错，所以先将n存入long变量m，再用m操作
    long m = n;
    if(m < 0) {
        x = 1 / x;
        m = -m;
    }
    // 快速幂 
    double ans = 1.0;
    while(m > 0) {
        if((m & 1) == 1){
            ans = ans*x;
            // 需要取余
            //ans = ans*x%mod
        }
        // 求x^1，x^2，x^4，x^8...
        x = x*x;
        // 需要取余
        // x =  x%mod;
        m = m >> 1;
    }
    return ans;
}
```

### 快速幂取模

求 $a^b \mod c$

- $a^b \mod c = (a \mod c)^{(b \mod c)}$
- $a*b \mod c = (a \mod c)*(b \mod c) \mod c$
  - 计算 $a*b \mod c$ 使用`long long`也有可能爆精度，此时需要转乘法为加法，在模拟的同时不断求模

```java
public int fastPower(int a, int n)
{
    if (n == 0)
        return 1;
    if (n % 2 == 1)
        return fastPower(a, n-1) % mod * (a % mod);
    int temp = fastPower(a, n/2) % mod;
    return temp * temp % mod;
}

public double fastPower(double x, int n) {
    if(x == 0){
        return 0;
    }
    long m = n;
    if(m < 0) {
        x = 1 / x;
        m = -m;
    }
    double ans = 1.0;
    while(m > 0) {
        if((m & 1) == 1){
            ans = (ans*x) % mod;
        }
        // 求x^1，x^2，x^4，x^8...
        x = (x*x) % mod;
        m = m >> 1;
    }
    return ans;
}
```

### 矩阵快速幂

在计算$x^n$时，只要x的数据类型支持**乘法**且**满足结合律**，快速幂的算法都是有效的，矩阵和高精度整数都可以

- 较复杂类型的快速幂的时间复杂度不再是简单的`o(logn)`，它与底数的乘法的时间复杂度有关
- 需要重载相应的乘法运算符

```java
// 泛型的非递归快速幂
template <typeName T>
T  fastPower(T x, ll n)
{
    // 赋值为乘法单位元，可能要根据构造函数修改
    T ans = 1; 
    while (n)
    {
        if (n & 1)
            // 这里不用自乘，否则重载完*还要重载*=
            ans = ans * x; 
        n = n >> 1;
        x = x * x;
    }
    return ans;
}
```

**矩阵快速幂**的经典应用

- 求斐波那契数列

斐波那契数列
$$
F_n=
\left\{
\begin{aligned}
1, \quad n=0\\
1, \quad n=1\\
F_{n-1}+F_{n-2} \quad x\ge1\\
\end{aligned}
\right.
$$

矩阵A
$$
A = \left[\begin{matrix}0&1\\1&1\end{matrix}\right]
$$

矩阵乘法可以得到
$$
A \left[\begin{matrix}F_n\\F_{n+1}\end{matrix}\right] = \left[\begin{matrix}F_{n+1}\\F_n+F_{n+1}\end{matrix}\right]
=
\left[\begin{matrix}F_{n+1}\\F_{n+2}\end{matrix}\right]
$$
即
$$
\left[\begin{matrix}F_{n}\\F_{n+1}\end{matrix}\right]
= A \left[\begin{matrix}F_{n-1}\\F_n\end{matrix}\right]
= A^2 \left[\begin{matrix}F_{n-2}\\F_{n-1}\end{matrix}\right]
= A^{n-1} \left[\begin{matrix}F_1\\F_2\end{matrix}\right]
= A^n \left[\begin{matrix}F_0\\F_1\end{matrix}\right]
= A^n \left[\begin{matrix}1\\1\end{matrix}\right]
= A^n+A^n
= 2*A^n
$$

> 处理矩阵的乘法

## 素数筛

### 埃氏筛

时间复杂度：`o(nloglogn)`

**思想**

- 因为0和1不是素数，从2开始**将每个素数的倍数都标记成合数**
- 合数的倍数已经被合数的**素数因子**筛掉了

缺点

- 对于一个合数，有可能被不同的素数因子筛了多次

> 优化：`j`从`i*i`开始，因为`i*2~i*(i-1)`的数已经被`2*i~(i-1)*i`筛掉了
>

```java
public void Prime(){
    int[] vis = new int[n];   
    // 0和1不是素数
    vis[0] = 1; 
    vis[1] = 1;  
    for(int i=2; i<=n; i++){
        // 如果i是素数，i的所有倍数都不是素数
        if (vis[i] == 0) {
            // j从i*i开始
            for(int j=i*i; j<=n; j+=i) { 
                vis[j] = 1;
            }
        }
    } 
}
```

### 欧拉筛

时间复杂度：`o(n)`

思想

- 改进埃氏筛，让每个合数只被它的**最小素数因子**筛选，只被筛一次

```java
public void Prime(){
    int[] vis = new int[n];  
    int[] pri = new int[n];
    // 0和1不是素数
    vis[0] = 1; 
    vis[1] = 1;  
    for(int i=2; i<=n; i++){
        // 如果i是素数，i的所有倍数都不是素数
        if (vis[i] == 0) {
            //记录素数，prime[0]用来计数
            pri[prime[0]++] = i;
        }
        for(int j=1; j<=pri[0] && i*prime[j]<=n; j++){
            //  不是用i的倍数来消去合数，而是把pri里面记录的素数，升序来当做要消去合数的最小素因子
            vis[i*pri[j]] = 1;
            if(i % pri[j] == 0) {
                break;
            }
        }
    } 
}
```



# 经典算法

## 马拉车算法

[Manacher’s Algorithm](https://medium.com/hackernoon/manachers-algorithm-explained-longest-palindromic-substring-22cb27a5e96f)

- 本质是**对暴力算法的优化**
  - **从左到右一个字符一个字符**来处理字符串
- 时间复杂度：`o(n)`


> 发生中心扩展当且仅当最右回文子串的右边界被向右推，而右边界最多被推`n`次，所以时间复杂度是`o(n)`

### 预处理

对字符串进行预处理，解决奇偶长度问题（全部都是奇数长度）

1. 在所有的空隙（包括首尾）插入分隔符`#`
2. 再在开头插入`$`防止越界，字符串的末尾默认有`'\0'`，不用插入

### 回文半径`RL`

- 一个回文串中最右位置的字符到对称轴字符的距离称为回文半径
- `RL[i]`表示以第`i`个字符为对称轴的回文串的回文半径（`r-i+1`）

> 定义最左位置也可以，但一般对字符串都是从左往右处理

### 回文串长度`RL[i]-1`

拓展后的字符串的最大的`RL[i]-1`正好是原字符串中以`i`字符为对称轴的最长回文串的长度

### 回文串的起始位置

拓展后的字符串的最大`RL[i]`对应的`(i-RL[i])/2`就是原字符串的最大回文串的起始位置

> 在开头加上`$`就是处理`(i-RL[i])<0`的情况

### 求最大的`RL[i]`

需要记录和更新当前最靠右边的回文串

- 对称轴`pos`
- 最右位置`MaxRight`

> `MaxRight = pos + RL[pos] - 1`;

**思想**

先计算出**肯定可以的以i为中心的最短回文字符串的长度**

1. 初始化`pos = MaxRight = 0`

2. 开始遍历拓展后的字符串`i`，找到`i`关于`pos`的对称点`j = 2*pos - i`

   1. 由`pos-j = i-pos`推出`j = 2*pos - i`
   2. 初始化`i=1`(0是`$`)

3. 如果`i < MaxRight`

   1. 如果`RL[j] < MaxRight - i`

      1. 表示以`j`为中心的回文子串包含在以`pos`为中心的最靠右回文子串中
      2. 因为`i`和`j`对称，所以以i为中心的回文子串也包含在以`pos`为中心的最靠右回文子串中
      3. 所以`RL[i] = RL[2*pos - i] = RL[j]`

   2. 如果`RL[j] >= MaxRight - i`

      1. 表示以`j`为中心的回文子串不一定完全包含在以`pos`为中心的最靠右回文子串中

      2. 所以`RL[i] = MaxRight - i`

         > `RL[i]`至少为`MaxRight - i`，因为最右边界外的第一个字符`MaxRight + 1`关于`i`对称的字符不知道是否等于`MaxRight + 1`对应的字符

4. 如果`i > MaxRight`

   1. 字符在回文串外，不知道是否回文，`RL[i] = 1`

5. 所以通过之前遍历得出的的`pos`和`MaxRight`可以得出

   1. `RL[i] = MaxRight > i ? min(RL[2*pos-i], MaxRight-i) : 1`



然后在这个基础上通过**继续向两侧扩展**来计算`RL[i]`，而不用从0开始扩展

对`i`进行中心拓展得到具体的`RL[i]`，如果发现`i`对应的回文串的右边位置超过了`MaxRight`，就要更新对称轴`pos`和最右位置`MaxRight`

- `pos = i`
- `MaxRight = i + RL[i]`

```java
// 马拉车
class Solution {
    public String longestPalindrome(String s) {
        if (s.length() == 0 || s.length() == 1)
            return s;
        // 预处理
        char[] t = preTreat(s);
        // 回文半径
        int[] RL = new int[t.length];
        // 记录最右回文串的pos和MaxRight
        int pos = 0;
        int MaxRight = 0;
        // 记录最大回文长度和起始位置
        int ans = 0;
        int index = 0;
        // 第一位是$
        for(int i=1; i<t.length; i++){
            // 先求RL[i]的下界
            if(i < MaxRight){
                RL[i] = Math.min(RL[2*pos-i], MaxRight-i);
            } 
            else{
                RL[i] = t[i] != '#' ? 2 : 1;
            }
            // 再对剩下部分进行中心扩展,求RL[i]
            while(i-RL[i] >= 0 && i+RL[i] < t.length) {
                if(t[i-RL[i]] == t[i+RL[i]]) {
                    RL[i]++;
                }
                else{
                    break;
                }
            }
            // 更新pos和MaxRight
            if (i+RL[i]-1 > MaxRight) {
                pos = i;
                MaxRight = i + RL[i] - 1;
            }
            // 更新最大回文串长度
            if (RL[i]-1 > ans) {
                ans = RL[i] - 1;
                index = i;
            }
        }
        int start = (index-(ans+1))/2;
        return s.substring(start,start+ans);
    }
    public char[] preTreat(String s){
        StringBuilder sb = new StringBuilder();
        sb.append('$');
        sb.append('#');
        for (int i=0; i<s.length(); i++) {
            sb.append(s.charAt(i));
            sb.append('#');
        }
        return sb.toString().toCharArray();
    }
}   
```



## 约瑟夫环问题

`f(n,m) = (f(n-1,m) + m) % n`

解决方法

- 动态规划

- 时间复杂度：`o(n)`

### 问题状态

- 从n个数字（`0，1，2...n-1`）的圆环中不断删除第m个数字，直到最后只剩下1个数字，记为`f(n,m)`
- 第一轮删除一个数字后，圆环只有n-1个数字，所以从n-1个数字中不断删除的子问题记为`f(n-1,m)`

### 状态转移

1. 由于m可能大于n-1，所以删除的数字所在位置为：`m%n-1`

2. 删除数字后，圆环从`m%n`位置的数字开始，记为`t`

3. 剩下的圆环从t开始为：`t,t+1,t+2...0,1,2...t-3,t-2`

   1. 不是单纯的的`f(n-1,m)`，区间起始数字改变了
   2. 所以要找到以0开始的n-1个数字序列和以t为起始数字的`f(n-1,m)`的对应关系

4. `0，1，2...n-2`和`f(n-1,m)`对应的圆环（`t,t+1,t+2...0,1,2...t-3,t-2`）的映射关系如下

   - `0 -> t`
   - `1 -> t+1`
   - `2 -> t+2`
   - `... -> ...`
   - `n-t -> 0`
   - `n-t+1 -> 1`
   - `n-t+2 -> 2`
   - `... -> ...`
   - `n-3 -> t-3`
   - `n-2 -> t-2`

5. 可以得出映射关系为：`x' = (x+t) % n`

6. 所以算出`f(n-1,m)`的数字`x`后，可以通过递推关系式得到`f(n,m)`对应的数字`x'`

7. 即：`f(n,m) = (f(n-1,m) + t) % n`

      `f(n,m) = (f(n-1,m) + m%n) % n`

      `f(n,m) = (f(n-1,m) + m) % n`

### base case

- `f(1) = 0` 

即最后剩下的数字一定是位置0上面的数字，通过递推关系来判断出它在第n个数字中的位置

```java
public int lastRemaining(int n, int m) {
    int ans = 0;
    for(int i=1; i<=n; i++){
        ans = (ans + m) % i;
    }
    return ans;
}
```



## 蓄水池抽样

**问题**

- **总的样本数量未知**，从所有样本中抽取若干个
- **要求每个样本被抽到的概率相等**

**思想**

- 从前往后处理每个样本，每个样本为答案的概率是$\frac {1}{i}$（i为样本编号），最终可以确保每个样本成为答案的概率是$\frac {1}{n}$（n为样本总数）

**证明**

假设最终成为答案的样本编号为k，那么k成为答案的充要条件是

- 在遍历到k时被选中并且遍历大于k的所有元素时，均没有被选择（即不会覆盖k）



## 拒绝采样

### [470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

`rand7()`可生成`[1,7]`范围内的均匀随机整数，用`rand7()`实现`rand10()`，生成`[1,10]`范围内的均匀随机整数

**反向问题**：用`rand10()`生成`rand7()`

- 如果用`rand10()`生成`rand7()`，则只要不断调用`rand10()`直到生成`[1,7]`范围内的的一个数

> 证明
>
> - 如果第一次调用就生成`[1,7]`范围内的的一个数，则直接命中，概率是`0.1`
> - 如果第二次调用才命中，则第二次命中的概率是第一次未命中和第二次命中，概率是`0.3*0.1`
> - 第三次命中则是`(0.3)^2*0.1`
>
> 所以依次求和：`0.1 + 0.3*0.1 + (0.3)^2*0.1 +...+ (0.3)^(n-1)*0.1`就是$\frac{1}{7}$

#### 思想

- 用`rand7()`实现`rand10()`，则考虑将小范围的数映射到一个大范围的数


**加法**

- 最简单的方法是使用加法，使用两次`rand7()`，即`rand7()+rand7()`就可以生成`[2,14]`范围内的数，因为没有1，则可以考虑使用`rand7()+rand7()-1`，
- 但加法其实是存在问题的，因为5是可以由3+2和2+3组成，但14只能由7+7组成，概率是不相等的

> 所以简单的加减法不行

**乘法**

**前提**：`(randX() - 1)*Y + randY()`可以等概率的生成`[1, X*Y]`范围的随机数，即`randX*Y()`

构建`(rand7()-1)*7 + rand7()`

- `rand7()-1`可以生成`[0,1,2,3,4,5,6]`，`(rand7()-1)*7`则可以生成`[0,7,14,21,28,35,42]`
- `rand7()`可以生成`[1,2,3,4,5,6,7]`

所以整个式子就可以生成`[1,49]`范围内的数，所以一直调用知道获得`[1,10]`之间的数即可

```java
public int rand10() {
    // 首先得到一个数
    int num = (rand7() - 1) * 7 + rand7();
    // 只要还大于10就继续生成，只要范围在1-10的数
    while (num > 10) {
        num = (rand7() - 1) * 7 + rand7();
    }
    return num;
}
```

**优化**

乘法可以生成`[1,49]`，但只需要`[1,10]`，所以`[11,49]`都会被过滤掉，效率很低，因此可以通过**减小过滤掉数的范围**来提高效率

 *      保留`[1,40]` 剩下`[41,49]`，因为`[1,40]`可以等概率的映射到`[1,10]`
*      **映射**：`1 + num % 10`

```java
public int rand10() {
    // 首先得到一个数
    int num = (rand7() - 1) * 7 + rand7();
    // 只要还大于10就继续生成，只要范围在1-10的数
    while (num > 10) {
        num = (rand7() - 1) * 7 + rand7();
    }
    // +1是考虑40映射到0
    return 1 + num % 10;
}
```

**再优化**

考虑进一步减小过滤掉数的范围

- 因为剩下的`[41,49]`也是等概率的，在经过`1 + num % 10`映射后`[1,9]`，相当于`rand9()`
- 所以问题转换为用`rand9()`生成`rand10()`

所以构建`(rand9()-1)*7 + rand7()`

- 相当于生成了`[1,63]`，保留`[1,60]` 剩下`[61,63]`
- 在经过`1 + num % 10`映射后`[1,3]`，相当于`rand3()`

再构建`(rand3()-1)*7 + rand7()`

- 相当于生成了`[1,21]`，保留`[1,20]` 剩下1，完成

> 即拒绝采样中的拒绝数可以继续用来生成符合的随机数，拒绝数也相当于一个`randm()`
>
> 最终当拒绝值为1个的时候就可以直接返回，因为拒绝采样足够小，效率已经最高了

```java
/**
 * The rand7() API is already defined in the parent class SolBase.
 * public int rand7();
 * @return a random integer in the range 1 to 7
 */
class Solution extends SolBase {
    public int rand10() {
        while (true) {
            // 随机生成一个数
            int ans = (rand7()-1)*7 + rand7();
            if (ans <= 40) {
                return ans%10 + 1;
            }
            // 由[41,49]生成[1,63]
            ans = (ans-40 - 1)*7 + rand7();
            if (ans <= 60) {
                return ans%10 + 1;
            }
            // 由[61,63]生成[1,21]
            ans = (ans-60 - 1)*7 + rand7();
            if (ans <= 20) {
                return ans%10 + 1;
            }
            // 拒绝21
        }
    }
}
```

# 设计

## [380. O(1) 时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)

```java
class RandomizedSet {

    Map<Integer,Integer> dict;
    List<Integer> list;
    Random rand = new Random();
    public RandomizedSet() {
        dict = new HashMap<>();
        list = new ArrayList();
    }
    
    public boolean insert(int val) {
        if(dict.containsKey(val)){
            return false;
        }
        // 列表存数,哈希表存索引位置
        dict.put(val,list.size());
        list.add(list.size(),val);
        return true;
    }
    
    public boolean remove(int val) {
        if(!dict.containsKey(val)){
            return false;
        }
        // 拿出列表最后一个数,用于交换
        // 使用最后一个数,才不会改变存储的前面数的索引
        int last = list.get(list.size()-1);
        // 获取要删除数的索引,用于交换
        int index = dict.get(val);
        // 覆盖,达到删除的效果
        list.set(index,last);
        // 重新存储
        dict.put(last,index);
        // 删除
        list.remove(list.size()-1);
        dict.remove(val);
        return true;
    }
    
    public int getRandom() {
        return list.get(rand.nextInt(list.size()));
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```

