# 算法性质

- 有穷性

- 确定性

- 可行性

- 输入

- 输出


# 算法分析

- 比较算法性能
  - 分析**最坏情况**下算法运行时间
- 输入规模n
  - 时间复杂度 `T(n)`
- **渐进分析**：
  - 忽略T(n)的系数和低阶项，**只关注高阶项**
    - 渐进紧确界`O(n)`
    - 渐进上界`θ(n)`
    - 渐进下界`Ω(n)`

> 调和级数：log n

通常最坏情况确定上界，用渐进上界`O(n)`表示时间复杂度



# Sort

## 插入排序

将排序好的数组从后往前与未排序的元素一一对比，将元素插入到对应位置。

## 选择排序

每次从未排序的数组中选出最小的元素，将最小元素和开始的元素交换。

## 快速排序

如果写i,x不能取q[l]，如果写j,x不能取q[r]，会死循环

```c++
void quick_sort(int q[],l,r){
    // 定界 l==r 也行
    if(l >= r) return;				
    // 从两侧的+1位置开始，先移动
    int x = q[(l+r)/2], i = l-1, j = r + 1;	
    while(i < j){
        // 保证i前面的数都是小于x
        do i++; while(q[i] < x);
        // 保证j后面的数都是大于x
        do j--; while(q[j] > x); 			
        if(i < j){	
            // swap(q[i],q[j]); i,j没相遇的时候交换即可   
     		int t = q[i];
            q[i] = q[j];					
            q[j] = t;  
        }
    }
    quick_sort(q,1,j);						 
    quick_sort(q,j+1,r);
    // quick_sort(q,l,i-1);
    // quick_sort(q,i,r);
}																																												
```





## 归并排序

1. 递归
2. 合并

**问题特点**

- 局部有序性

**步骤**

1. 处理待排序数组（不具备局部有序性的特点）：分解至数组长度为1时天然有序

2. 递归解决子问题：得到2个有序数组

3. 合并有序子数组

   > 快速合并：比较2个有序数组的当前最小元素，将较小者逐一合并 

```c++
int tmp[N];
void merge_sort(int q[],int l,int r){
    if(l >= r){
        return;
    }
    int mid = (l + r) >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid+1, r);
    int k = 0, i = l, j = mid+1;			
    // merge函数
    while(i <= mid && j <= r){				
        if(q[i] <= q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];
    }
    while(i <= mid)	tmp[k++] = q[i++];
    while(j <= r) tmp[k++] = q[j++];
    for(i=l,j=0; i<=r; i++,j++)q[i] = tmp[j];
}
```



# 水题

## [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)

int 范围：-2147483648~2147483647（10位数）

如何在循环中判断溢出：

```java
if ((ans * 10) / 10 != ans)
```

ans * 10未溢出时 ans * 10个位为0, 故ans * 10 + x%10没有进位。但并不是没有进位就不溢出，而是末位是正数不能大于7，是负数不能小于-8 。但**原数在int范围内，当它是10位数时才可能溢出，此时第一位一定是1或2** 。那么反转最后一位也就是1或2，那么ans * 10加上它也不会溢出。

> (ans * 10)溢出的时候Java可以暂存，C不可以

## [9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

考虑只反转 int 数字的一半：如何判断位数到一半了（奇，偶？）

奇位数的中间位数字不影响回文。

当**原始数字小于或等于反转后的数字**时，表示已经处理了一半位数的数字。

```c
while (x > revertedNumber) {
    revertedNumber = revertedNumber * 10 + x % 10;
    x /= 10;
}
```



# Array

## [169. 主要元素](https://leetcode-cn.com/problems/find-majority-element-lcci/)

数组中一个数出现的次数超过数组长度的一半

- 那么在排序后，出现在数组中间的数字一定就是那个数（统计学上的中位数：有一半的数比它大，有一半的数比它小）
- 它出现的次数比其他所有数出现的次数都多（用其他数和它消除，最后还会剩下它）

# BinarySearch

## while()

**搜索闭区间[left,right]**

- 当没有搜索到目标值时，`left = right+1 (left > right)`循环时终止
- 此时**区间为空**，返回-1即可

```java
// 1.
int left = 0;
int right = nums.length-1;
while(left <= rigth){
    
}
return -1;
```

**搜索开区间[left,right)**

- 当没有搜索到目标值时，`left = right`时循环终止
- 此时**区间非空**，是`[right,right]`，所以还需要单独判断`nums[right]`

```java
// 2.
int left = 0;
int right = nums.length-1;
while(left < rigth){
    
}

## left/right

当`nums[mid]`不满足条件，继续搜索计算区间时

**搜索闭区间[left,right]**

`mid`已经包含在搜索区间中了，下一步搜索

- `[left,mid-1]`
- `[mid+1,right]`

所以两个区间都要剔除`mid`

```java
left = mid+1;
right = mid-1;
```

**搜索开区间[left,right)**

右边是开区间，包括`left`，不包括`right`，所以下一步搜索

- `[left,mid)`
  - 需要剔除`mid`
- `[mid,right)`
  - 不需要剔除`mid`

```java
left = mid+1;
right = mid;
```

## else if

将所有的条件写成`else if`，不使用`else`

## mid

防止left和right太大直接相加导致溢出

`int mid = left + (right - left) / 2;`



## 左侧边界

左侧边界的意义

排序数组中，小于`nums[l]`的数有`l`个



# LinkedList

## [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

删除某个链表中给定的（非末尾）节点。

删除：**只要这个点的值变成下一个点的值，就表示这个点不在了**

```c
node->val = node->next->val;
node->next = node->next->next;
```

## [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

- 当要删除的一个或多个节点位于链表的头部，需要定位新的链表头指针`pre`

- 删除操作需要通过`->next`指针域判断，定义`pre`指针方便操作

**哨兵节点**：

用于删除节点，返回链表。其主要目的是使链表标准化，如使链表永不为空、永不无头、简化插入和删除

**双指针**

正常`cur`指针从`head`开始判断整个链表（cur->val == val）

-  `cur->val != val` 时2个指针同时向后移动一位。


-  `cur->val == val` 时需要删除这个节点，并且下次移动的时候`pre`指针需要跳过这个点，即

```c
cur = cur->next;
pre->next = cur;
```

## [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

- 正常：遍历长度逆推正数输出即可


- **栈**：

  压入后弹出即可（正反操作）

- **双指针**：可以不计算链表长度

  前指针`former`先走k步，然后两个指针一起走直到`former`为NULL。因为指针相距k步，后指针`latter`刚好在倒数节点处



有一种**模n同余**的感觉

> 给定一个正整数m，如果两个整数a和b满足 a-b 能够被m整除，那么就称整数a与b对模m同余，记作a≡b(mod m)。对模m同余是整数的一个等价关系

## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

- **递归**

  每次处理递归返回的尾节点是当前head的下一个节点

  ```c
  struct ListNode* reverseList(struct ListNode* head);
  
  last = reverseList(head->next);
  head->next->next = head;
  head->next = NULL;
  ```

- **迭代**

  每次将当前节点从链上摘下来放在前面一个节点的前面
  
  ```C
  pre->next = head;
  h = head;
  cur = head->next;
  
  while (cur) {
      h->next = cur->next;
      cur->next = pre->next;
      pre->next = cur;
      cur = h->next;
  }
  ```
  
  



## [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

**快慢指针**：

慢指针一次走 1 步，快指针一次走 2 步，当快指针走完的时候慢指针就来到了链表的中间位置。

```c
//注意边界判断
while (fast && fast->next) {
    fast = fast->next->next;
    slow = slow->next;
}
```

## [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

**快慢指针**：

如果链表存在环，快指针最后会追上慢指针。并且慢指针如果走了k，则快指针走了2k。那么差距k就是环的长度的整数倍（因为可能慢指针还没进入环的时候，快指针已经在环中循环n圈了），即**k= n*l**，l为环的长度。

## [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

**快慢指针**：

1. 当快指针追到慢指针时，假设慢指针走了k，则快指针走了2k
2. 假设快慢指针的相遇点和环的入口点相距**m**，因为慢指针走了k，所以head和入口点相距**k-m**
3. 此时，如果慢指针再向前走k-m就会回到环的入口点（等于慢指针之前从入口点走了m再走k-m一共k，绕了n圈环）。而head走k-m也会到达环的入口点，所以相遇点就是环的入口点。



# Stack/Queue

## [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

- 中缀表达式：正常使用的表达式，运算符在两个操作数的中间（a+b）由优先级判断顺序

- 后缀表达式（逆波兰式）：**运算符跟在两个操作数后**（abcde/-f+）

  运算规则：每个运算符和在它之前出现且紧靠它的两个操作数构成一个最小表达式

  **在堆栈中括号的优先级最低**

- 前缀表达式（波兰式）：**运算符在两个操作数前**（+ab-c/def）

  运算规则：连续出现的两个操作数和它们之前且紧靠它们的运算符构成一个最小表达式



 



# BinaryTree

**递归**

用自身定义自身

- 递归边界
- 递归式：和大问题性质相似的小问题

**二叉树**

- 严格区分左右子树
- 叶子节点数为n，度为2的节点数为m，则**n=m+1**（分支数推导）

> 和度为2的树的最主要区别

**二叉链表**

```c++
struct TreeNode{
    int data;
    TreeNode* lchild;
    TreeNode* rchild;
};

TreeNode* root = NULL;
```

**静态二叉链表**

- 用长度为二叉树节点个数的数组实现
- 所有动态生成的节点都用数组中的节点
- 使用数组下标访问二叉树的节点（代替指针）

```c++
struct TreeNode{
    int data;
    int lchild;
    int rchild;
}Node[maxn];
```



**特殊的二叉树**

- 斜树
  - 左斜树
  - 右斜树
- 满二叉树（完美）
  - 所有分支节点都存在左右子树
  - 所有叶子节点都在同一层
- 完全二叉树
  - 所有节点和同样深度的满二叉树的节点一一对应
  - 叶子节点只能出现在最下面**两层**
    - 最下层的叶子节点一定在左边连续位置
    - 倒数第二层的叶子节点一定在右边连续位置
  - 不存在只有右子树的节点（度为1一定是只有左子树）
  - 同样节点的数的二叉树，**深度最小**（n个节点深度为**向下取整(logn)+1**）

> 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树

**完全二叉树的存储**

可以使用长度为**2<sup>n</sup>**的数组存储所有节点

- nums[1]存放根节点
- n为完全二叉树的最大高度，即数组长度为完全二叉树的**节点总数+1**
- 数组中存放完全二叉树的节点顺序刚好是**层序遍历的顺序**

假设完全二叉树的任一节点编号为n

- 节点左孩子编号为**2*n**
- 节点右孩子编号为**2*n+1**

## 二叉树的插入

插入位置就是查找失败的位置

> 建树就是不断向二叉树插入节点

## 二叉树的遍历

**深度优先搜索DFS**

- 前序遍历preorder
- 中序遍历inorder
- 后序遍历hostorder

> 左子树一定先于右子树遍历

**广度优先搜索BFS**

- 层序遍历

> 非递归：队列实现

## 二叉树的还原

**根据遍历结果还原二叉树**

- 前序，后序，层遍历可以获得**根节点**
- 中序遍历可以根据前后序遍历获得的根节点来区分**左右子树**

> 必须知道中序遍历才能还原二叉树
>
> 必须要保证所有节点值不相同

**还原过程**

前序遍历：[p<sub>1</sub>，p<sub>2</sub>...p<sub>k</sub>，p<sub>k+1</sub>...p<sub>n</sub>]

中序遍历：[i<sub>1</sub>，i<sub>2</sub>...i<sub>k-1</sub>，i<sub>k</sub>，i<sub>k+1</sub>...i<sub>n</sub>]

1. 根据前序遍历得出p<sub>1</sub>是根节点root
2. 在中序遍历中找到**i<sub>k</sub>=p<sub>1</sub>**，根据i<sub>k</sub>划分左右子树
3. 根据中序遍历得出左子树节点个数**n=k-1**
4. 根据n得出在前序遍历中左子树的区间为[p<sub>2</sub>,p<sub>k</sub>]，右子树区间为[p<sub>k+1</sub>,p<sub>n</sub>]
5. 根据n得出在中序遍历中左子树的区间为[i<sub>1</sub>,i<sub>k-1</sub>]，右子树区间为[i<sub>k+1</sub>,i<sub>n</sub>]
6. 根据左，右子树的前，中序遍历递归还原二叉树

> 子树的前序遍历区间是[p<sub>l</sub>,p<sub>r</sub>]，中序遍历区间是[i<sub>l</sub>,i<sub>r</sub>]，且i<sub>k</sub>=p<sub>l</sub>，则左子树节点个数n=k-i<sub>l</sub>
>
> 左子树的前序遍历区间为[p<sub>l+1</sub>,p<sub>l+n</sub>]，左子树的中序遍历区间为[i<sub>l</sub>,i<sub>k-1</sub>]
>
> 右子树的前序遍历区间为[p<sub>l+n+1</sub>,p<sub>r</sub>]，左子树的中序遍历区间为[i<sub>k+1</sub>,i<sub>r</sub>]

**递归终止条件**

当前序区间长度<=0时结束（不存在二叉树）

```java
public TreeNode create(int[] pre,int[] in,int pl,int pr,int il,int lr){
    // 递归终止
    if(pl > pr){
        return null;
    }
    // 创建根节点
    TreeNode root = new TreeNode(pre[pl]);
    int i;
    for(i=il; i<=ir; i++){
        if(in[i] == pre[pl]){
            break;
        }
    }
    int n = i-il;
    root.left = create(pre,in,pl+1,pl+n,il,i-1);
    root.right = create(pre,in,pl+n+1,pr,i+1,ir);
    return root;
}
```



## [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

**树的高度和深度**

- 深度定义是从上往下的
- 高度定义是从下往上的

**树的遍历**

- 前序遍历：根左右，从上往下，符合深度定义的
- 后序遍历：左右根，从下往上，符合高度定义的

## [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

最小深度是从根节点到最近叶子节点的最短路径上的节点数量

当只有一棵子树为空时，哪条路径不是叶子节点路径

解决方法：不参与比较



# BitOperation

- `&`
- `|`
- `^`
- `~`

## [1470. 重新排列数组](https://leetcode-cn.com/problems/shuffle-the-array/)

**思路一**

数据是二进制表示，**用数存数**

题目限制数据范围最大只能是1000，所以每一个元素最多只占据了10bit（2^10 - 1 = 1023 > 1000）而`int`类型占32bit，所以可以使用剩下的22bit做存储，本题只用10bit就够了。

1. 数据的低10位（0-9） 存储原本的数据
2. 往前10位（10-19 ）存储重新排列的数据
3. 取数据的前10位就是答案（右移10位）

`&`：二进制**取位**操作，0x3FF即1023（10进制），1111111111（2进制）

`|`：二进制特定位上的无条件赋值

```java
// 奇偶位
j = i < n ? i*2 : (i-n)*2+1;
// & 取二进制的低10位, | 赋值到前10位
nums[j] |= (nums[i] & 0x3FF) << 10;
nums[j] >> 10
```

**思路二**

题目限制数据范围都是正数，可以用负数做标记

1. 将nums[i]存到应该的位置nums[j]上，并标记为数据的相反数
2. 将nums[j]存到nums[i]上，并根据之前的j计算它应该在的位置，继续交换，标记为相反数
3. 直到所有数都标记为相反数（负数）
4. 转换回正数

